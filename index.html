<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Runner Auto-Shooter Demo</title>
  <style>
    html, body { margin:0; height:100%; background:#0b0f14; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    canvas { display:block; width:100vw; height:100vh; touch-action:none; }
    .hud {
      position:fixed; left:12px; top:12px; color:#cfe6ff; font-size:14px; line-height:1.25;
      background: rgba(16,22,30,.55); border:1px solid rgba(160,200,255,.15);
      padding:10px 12px; border-radius:12px; backdrop-filter: blur(8px);
      user-select:none;
    }
    .hint { opacity:.8; font-size:12px; margin-top:6px; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="hud" id="hud">
    <div><b>Auto Shooter Runner</b></div>
    <div>Юниты: <span id="units">1</span> · HP: <span id="hp">10</span> · Счёт: <span id="score">0</span></div>
    <div class="hint">Двигай пальцем/мышью влево-вправо. Стрельба — автоматом. Проходи через ворота + / x.</div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  const hudUnits = document.getElementById('units');
  const hudHP = document.getElementById('hp');
  const hudScore = document.getElementById('score');

  // ----- Resize (HiDPI)
  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  addEventListener('resize', resize, { passive: true });
  resize();

  // ----- World
  const W = () => innerWidth;
  const H = () => innerHeight;

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a, b) => a + Math.random() * (b - a);

  const state = {
    t: 0,
    running: true,
    score: 0,

    // player lane
    playerX: W() * 0.5,
    playerY: H() * 0.78,
    speedY: 220, // "бег" вверх по экрану (мир едет вниз)
    units: 6,    // количество "персонажей" (сила стрельбы)
    hp: 10,

    bullets: [],
    enemies: [],
    gates: [],
    particles: [],

    shootCooldown: 0,
    spawnCooldown: 0,
    gateCooldown: 0,

    targetX: W() * 0.5,
  };

  // ----- Input
  function setTargetFromEvent(e) {
    const x = (e.touches ? e.touches[0].clientX : e.clientX);
    state.targetX = x;
  }
  canvas.addEventListener('pointerdown', setTargetFromEvent);
  canvas.addEventListener('pointermove', setTargetFromEvent);
  canvas.addEventListener('touchstart', setTargetFromEvent, { passive: true });
  canvas.addEventListener('touchmove', setTargetFromEvent, { passive: true });

  // ----- Helpers: particles
  function puff(x, y, n, spd, lifeMin=0.2, lifeMax=0.6) {
    for (let i=0;i<n;i++) {
      const a = rand(0, Math.PI*2);
      const s = rand(spd*0.4, spd);
      state.particles.push({
        x, y,
        vx: Math.cos(a)*s,
        vy: Math.sin(a)*s,
        life: rand(lifeMin, lifeMax),
        max: 0
      });
    }
  }

  // ----- Gates
  // gate types: add (+N) or mul (x2/x3)
  function spawnGate() {
    const x = rand(W()*0.18, W()*0.82);
    const y = -60;
    const isMul = Math.random() < 0.45;
    let val, label;
    if (isMul) {
      val = Math.random() < 0.7 ? 2 : 3;
      label = "x" + val;
    } else {
      val = Math.random() < 0.7 ? 10 : 20;
      label = "+" + val;
    }
    state.gates.push({
      x, y,
      w: 140, h: 46,
      isMul,
      val,
      label,
      taken: false
    });
  }

  // ----- Enemies
  function spawnEnemyWave() {
    // формируем "линию" врагов сверху
    const cols = Math.floor(rand(4, 9));
    for (let i=0;i<cols;i++) {
      const x = (W()/(cols+1))*(i+1) + rand(-16, 16);
      const y = rand(-180, -60);
      const r = rand(14, 22);
      state.enemies.push({
        x, y, r,
        hp: Math.ceil(r/6),
        vx: rand(-20, 20),
        vy: rand(40, 70) // доп. скорость вниз (мир тоже движется)
      });
    }
  }

  // ----- Shooting
  function shoot(dt) {
    state.shootCooldown -= dt;
    if (state.shootCooldown > 0) return;

    // rate depends on units
    const rate = clamp(0.28 - Math.log10(state.units+1)*0.06, 0.08, 0.28);
    state.shootCooldown = rate;

    // spread: shoot multiple bullets based on units (but limit)
    const bulletsCount = clamp(Math.floor(state.units/3), 1, 10);
    const spread = clamp(0.18 + bulletsCount*0.03, 0.18, 0.55);

    for (let i=0;i<bulletsCount;i++) {
      const k = bulletsCount===1 ? 0 : (i/(bulletsCount-1))*2-1; // -1..1
      const angle = k * spread;
      const speed = 820;
      state.bullets.push({
        x: state.playerX,
        y: state.playerY - 24,
        vx: Math.sin(angle) * speed,
        vy: -Math.cos(angle) * speed,
        r: 4,
        dmg: 1 + Math.floor(Math.log2(state.units+1)/2),
      });
    }
  }

  // ----- Collisions
  function circleHit(ax, ay, ar, bx, by, br) {
    const dx = ax - bx, dy = ay - by;
    const rr = ar + br;
    return dx*dx + dy*dy <= rr*rr;
  }

  // ----- Game loop
  let last = performance.now();
  function tick(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    state.t += dt;

    // update player
    const smooth = 12;
    state.playerX += (state.targetX - state.playerX) * (1 - Math.exp(-smooth*dt));
    state.playerX = clamp(state.playerX, 28, W()-28);

    // auto shoot
    if (state.running) shoot(dt);

    // spawn enemies
    state.spawnCooldown -= dt;
    if (state.spawnCooldown <= 0) {
      state.spawnCooldown = rand(0.55, 1.05);
      spawnEnemyWave();
    }

    // spawn gates
    state.gateCooldown -= dt;
    if (state.gateCooldown <= 0) {
      state.gateCooldown = rand(1.2, 2.0);
      spawnGate();
    }

    // move world objects down (as if player runs forward)
    const worldDown = state.speedY * dt;

    // bullets
    for (const b of state.bullets) {
      b.x += b.vx * dt;
      b.y += b.vy * dt + worldDown * 0.2; // чуть компенсируем "движение мира"
    }
    state.bullets = state.bullets.filter(b => b.y > -80 && b.y < H()+80 && b.x > -80 && b.x < W()+80);

    // enemies
    for (const e of state.enemies) {
      e.x += e.vx * dt;
      e.y += (e.vy * dt) + worldDown;
      if (e.x < e.r || e.x > W()-e.r) e.vx *= -1;
    }

    // gates
    for (const g of state.gates) g.y += worldDown;

    // particles
    for (const p of state.particles) {
      p.x += p.vx * dt;
      p.y += p.vy * dt + worldDown * 0.15;
      p.life -= dt;
    }
    state.particles = state.particles.filter(p => p.life > 0);

    // bullet vs enemy
    for (const b of state.bullets) {
      for (const e of state.enemies) {
        if (e.hp <= 0) continue;
        if (circleHit(b.x, b.y, b.r, e.x, e.y, e.r)) {
          e.hp -= b.dmg;
          b.y = -9999; // mark remove
          puff(e.x, e.y, 8, 240);
          if (e.hp <= 0) {
            state.score += 10;
            puff(e.x, e.y, 14, 420);
          }
          break;
        }
      }
    }
    state.bullets = state.bullets.filter(b => b.y > -2000);

    // enemy hits player
    for (const e of state.enemies) {
      if (e.hp <= 0) continue;
      if (circleHit(state.playerX, state.playerY, 18, e.x, e.y, e.r)) {
        e.hp = 0;
        state.hp -= 1;
        puff(e.x, e.y, 18, 520);
        if (state.hp <= 0) state.running = false;
      }
    }

    // gate pickup
    for (const g of state.gates) {
      if (g.taken) continue;
      // treat gate as capsule collision
      const dx = Math.abs(state.playerX - g.x);
      const dy = Math.abs(state.playerY - g.y);
      if (dx < g.w*0.5 && dy < g.h*0.7) {
        g.taken = true;
        if (g.isMul) state.units = Math.min(999, state.units * g.val);
        else state.units = Math.min(999, state.units + g.val);
        puff(g.x, g.y, 22, 500);
      }
    }

    // cleanup
    state.enemies = state.enemies.filter(e => e.y < H()+120 && e.hp > 0);
    state.gates = state.gates.filter(g => g.y < H()+120 && !g.taken);

    // render
    render();

    // HUD
    hudUnits.textContent = state.units;
    hudHP.textContent = state.hp;
    hudScore.textContent = state.score;

    // game over text
    if (!state.running) {
      drawGameOver();
    } else {
      requestAnimationFrame(tick);
    }
  }

  function render() {
    // background
    ctx.fillStyle = '#0b0f14';
    ctx.fillRect(0, 0, W(), H());

    // subtle lanes
    ctx.globalAlpha = 0.16;
    ctx.strokeStyle = '#87bfff';
    ctx.lineWidth = 1;
    for (let i=1;i<5;i++) {
      const x = (W()/5)*i;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, H());
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // gates
    for (const g of state.gates) {
      ctx.save();
      ctx.translate(g.x, g.y);
      ctx.fillStyle = g.isMul ? 'rgba(120,220,255,0.18)' : 'rgba(140,255,170,0.16)';
      ctx.strokeStyle = g.isMul ? 'rgba(120,220,255,0.65)' : 'rgba(140,255,170,0.65)';
      roundRect(-g.w/2, -g.h/2, g.w, g.h, 14);
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = 'rgba(215,240,255,0.95)';
      ctx.font = '700 18px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(g.label, 0, 1);
      ctx.restore();
    }

    // enemies
    for (const e of state.enemies) {
      ctx.beginPath();
      ctx.fillStyle = 'rgba(255,90,90,0.92)';
      ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
      ctx.fill();

      // small hp ring
      ctx.globalAlpha = 0.5;
      ctx.strokeStyle = 'rgba(255,220,220,0.9)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.r+4, -Math.PI/2, -Math.PI/2 + (Math.PI*2)*clamp(e.hp/4,0,1));
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // bullets
    for (const b of state.bullets) {
      ctx.beginPath();
      ctx.fillStyle = 'rgba(200,240,255,0.95)';
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
    }

    // particles
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = 'rgba(200,240,255,0.55)';
    for (const p of state.particles) {
      const r = 2.2 * clamp(p.life/0.6, 0.2, 1);
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // player (core + aura showing "units")
    const aura = clamp(16 + Math.log(state.units+1)*6, 18, 60);
    ctx.beginPath();
    ctx.fillStyle = 'rgba(90,170,255,0.18)';
    ctx.arc(state.playerX, state.playerY, aura, 0, Math.PI*2);
    ctx.fill();

    ctx.beginPath();
    ctx.fillStyle = 'rgba(120,220,255,0.95)';
    ctx.arc(state.playerX, state.playerY, 18, 0, Math.PI*2);
    ctx.fill();

    // "count" label
    ctx.fillStyle = 'rgba(10,15,20,0.9)';
    ctx.font = '800 12px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(String(state.units), state.playerX, state.playerY+1);
  }

  function drawGameOver() {
    // overlay
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    ctx.fillRect(0, 0, W(), H());

    ctx.fillStyle = 'rgba(220,245,255,0.95)';
    ctx.font = '800 34px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('GAME OVER', W()/2, H()*0.42);

    ctx.font = '600 16px system-ui';
    ctx.fillText(`Счёт: ${state.score}`, W()/2, H()*0.49);

    ctx.font = '600 14px system-ui';
    ctx.globalAlpha = 0.85;
    ctx.fillText('Нажми/тапни чтобы перезапустить', W()/2, H()*0.56);
    ctx.globalAlpha = 1;

    const restart = () => {
      // reset
      state.running = true;
      state.score = 0;
      state.units = 6;
      state.hp = 10;
      state.bullets.length = 0;
      state.enemies.length = 0;
      state.gates.length = 0;
      state.particles.length = 0;
      state.shootCooldown = 0;
      state.spawnCooldown = 0.2;
      state.gateCooldown = 0.8;
      last = performance.now();
      canvas.removeEventListener('pointerdown', restart);
      requestAnimationFrame(tick);
    };
    canvas.addEventListener('pointerdown', restart, { once: true });
  }

  function roundRect(x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  // start
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>