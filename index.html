<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä—É–∫–æ–ø–∏—Å–Ω—ã—Ö —Ü–∏—Ñ—Ä (0‚Äì9)</title>
  <style>
    :root { font-family: -apple-system, system-ui, Arial; }
    body { margin:0; background:#0b0d12; color:#e9eefc; }
    .wrap { max-width: 920px; margin: 0 auto; padding: 18px; }
    h1 { margin: 10px 0 6px; font-size: 24px; }
    .sub { margin: 0 0 12px; opacity:.8; line-height:1.35; }
    .card { background:#111626; border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:14px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:10px 0; }
    button { border:0; border-radius:12px; padding:12px 14px; font-weight:700; background:#2a6bff; color:#fff; }
    button.ghost { background:transparent; border:1px solid rgba(255,255,255,.18); }
    button:disabled { opacity:.4; }
    .canvasWrap { display:flex; gap:12px; flex-wrap:wrap; align-items:flex-start; }
    canvas { background:#000; border-radius:14px; border:1px solid rgba(255,255,255,.12); touch-action:none; }
    .panel { min-width: 260px; flex: 1; }
    .big { font-size: 54px; font-weight: 900; margin: 6px 0; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 13px; opacity:.9; }
    details { margin-top:10px; opacity:.9; }
    summary { cursor: pointer; }
    .warn { opacity: .85; }
  </style>
</head>
<body>
  <main class="wrap">
    <h1>–ù–µ–π—Ä–æ—Å–µ—Ç—å: —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä—É–∫–æ–ø–∏—Å–Ω—ã—Ö —Ü–∏—Ñ—Ä</h1>
    <p class="sub">–†–∏—Å—É–π —Ü–∏—Ñ—Ä—É (0‚Äì9) ‚Üí ¬´–£–≥–∞–¥–∞—Ç—å¬ª. –ù–∞–∂–º–∏ ¬´–û–±—É—á–∏—Ç—å¬ª, —á—Ç–æ–±—ã —Å—Ç–∞–ª–æ —Ç–æ—á–Ω–µ–µ. –í—Å—Ç—Ä–æ–µ–Ω–∞ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –æ—à–∏–±–æ–∫ (–ø–æ–∫–∞–∂–µ—Ç –ø—Ä–∏—á–∏–Ω—É –ø—Ä—è–º–æ –≤ —Å—Ç–∞—Ç—É—Å–µ).</p>

    <section class="card">
      <div class="canvasWrap">
        <div>
          <canvas id="draw" width="280" height="280"></canvas>
          <div class="row">
            <button id="btnClear" class="ghost">–°—Ç–µ—Ä–µ—Ç—å</button>
            <button id="btnGuess">ü§ñ –£–≥–∞–¥–∞—Ç—å</button>
          </div>
        </div>

        <div class="panel">
          <div>–°—Ç–∞—Ç—É—Å: <b id="status">–∑–∞–≥—Ä—É–∑–∫–∞‚Ä¶</b></div>
          <div class="big" id="pred">‚Äî</div>
          <div class="mono" id="conf">–£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: ‚Äî</div>
          <div class="mono">–¢–æ–ø-3: <span id="top3">‚Äî</span></div>

          <div class="row">
            <button id="btnTrain">üéì –û–±—É—á–∏—Ç—å (—Ç–æ—á–Ω–µ–µ)</button>
            <button id="btnSave" class="ghost" disabled>üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
            <button id="btnLoad" class="ghost">üì¶ –ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
          </div>

          <p class="mono warn" id="hint">
            –ü–æ–¥—Å–∫–∞–∑–∫–∞: –µ—Å–ª–∏ ¬´–£–≥–∞–¥–∞—Ç—å¬ª –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, —Å—Ç–∞—Ç—É—Å –ø–æ–∫–∞–∂–µ—Ç –æ—à–∏–±–∫—É (—ç—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ ‚Äî –ø—Ä–æ—Å—Ç–æ —Å–∫–∞–∂–∏ –º–Ω–µ —Ç–µ–∫—Å—Ç –æ—à–∏–±–∫–∏).
          </p>

          <details>
            <summary>–ü–æ–¥—Å–∫–∞–∑–∫–∏ –ø–æ —Ä–∏—Å–æ–≤–∞–Ω–∏—é</summary>
            <ul>
              <li>–†–∏—Å—É–π –±–ª–∏–∂–µ –∫ —Ü–µ–Ω—Ç—Ä—É, –æ–¥–Ω–∏–º —à—Ç—Ä–∏—Ö–æ–º, –ø–æ—Ç–æ–ª—â–µ.</li>
              <li>–ï—Å–ª–∏ –ø—É—Ç–∞–µ—Ç 1/7 –∏–ª–∏ 3/8 ‚Äî —Ä–∏—Å—É–π —Ä–∞–∑–ª–∏—á–∏–º–µ–µ.</li>
              <li>¬´–°–æ—Ö—Ä–∞–Ω–∏—Ç—å¬ª –∫–ª–∞–¥—ë—Ç –º–æ–¥–µ–ª—å –≤ –ø–∞–º—è—Ç—å –±—Ä–∞—É–∑–µ—Ä–∞ –Ω–∞ iPhone (IndexedDB).</li>
            </ul>
          </details>
        </div>
      </div>
    </section>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>

  <script>
    // ================== UI helpers ==================
    const $ = (id) => document.getElementById(id);

    const canvas = $('draw');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });

    const btnClear = $('btnClear');
    const btnGuess = $('btnGuess');
    const btnTrain = $('btnTrain');
    const btnSave  = $('btnSave');
    const btnLoad  = $('btnLoad');

    const statusEl = $('status');
    const predEl   = $('pred');
    const confEl   = $('conf');
    const top3El   = $('top3');

    function setStatus(s){ statusEl.textContent = s; }
    function setOut(pred, conf, top3){
      predEl.textContent = pred;
      confEl.textContent = conf;
      top3El.textContent = top3;
    }

    // –ü–æ–∫–∞–∑ –æ—à–∏–±–æ–∫ –ø—Ä—è–º–æ –≤ UI (–≤–∞–∂–Ω–æ –¥–ª—è iPhone, –≥–¥–µ –∫–æ–Ω—Å–æ–ª—å –æ–±—ã—á–Ω–æ –Ω–µ –≤–∏–¥–Ω–∞)
    window.addEventListener('error', (e) => {
      setStatus('–û—à–∏–±–∫–∞: ' + (e.message || 'unknown'));
    });
    window.addEventListener('unhandledrejection', (e) => {
      setStatus('Promise error: ' + (e.reason?.message || e.reason || 'unknown'));
    });

    // ================== Drawing ==================
    function clearCanvas(){
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 22;
      setOut('‚Äî','–£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: ‚Äî','‚Äî');
      setStatus('–≥–æ—Ç–æ–≤–æ: —Ä–∏—Å—É–π –∏ –∂–º–∏ ¬´–£–≥–∞–¥–∞—Ç—å¬ª (–¥–ª—è —Ç–æ—á–Ω–æ—Å—Ç–∏ ‚Äî ¬´–û–±—É—á–∏—Ç—å¬ª)');
    }
    clearCanvas();

    let drawing = false;
    let lastX = 0, lastY = 0;

    function getPos(e){
      const r = canvas.getBoundingClientRect();
      const t = e.touches?.[0];
      const x = (t ? t.clientX : e.clientX) - r.left;
      const y = (t ? t.clientY : e.clientY) - r.top;
      return { x, y };
    }

    function startDraw(e){
      drawing = true;
      const {x,y} = getPos(e);
      lastX = x; lastY = y;
      e.preventDefault();
    }
    function moveDraw(e){
      if(!drawing) return;
      const {x,y} = getPos(e);
      ctx.beginPath();
      ctx.moveTo(lastX,lastY);
      ctx.lineTo(x,y);
      ctx.stroke();
      lastX = x; lastY = y;
      e.preventDefault();
    }
    function endDraw(){ drawing = false; }

    canvas.addEventListener('mousedown', startDraw);
    canvas.addEventListener('mousemove', moveDraw);
    window.addEventListener('mouseup', endDraw);

    canvas.addEventListener('touchstart', startDraw, { passive:false });
    canvas.addEventListener('touchmove', moveDraw, { passive:false });
    canvas.addEventListener('touchend', endDraw);

    btnClear.addEventListener('click', clearCanvas);

    // ================== Model ==================
    let model = null;

    function buildModel(){
      const m = tf.sequential();
      m.add(tf.layers.conv2d({ inputShape:[28,28,1], filters:16, kernelSize:3, activation:'relu' }));
      m.add(tf.layers.maxPooling2d({ poolSize:2 }));
      m.add(tf.layers.conv2d({ filters:32, kernelSize:3, activation:'relu' }));
      m.add(tf.layers.maxPooling2d({ poolSize:2 }));
      m.add(tf.layers.flatten());
      m.add(tf.layers.dense({ units:64, activation:'relu' }));
      m.add(tf.layers.dropout({ rate:0.2 }));
      m.add(tf.layers.dense({ units:10, activation:'softmax' }));
      m.compile({ optimizer: tf.train.adam(0.001), loss:'categoricalCrossentropy', metrics:['accuracy'] });
      return m;
    }

    // ---------- Better preprocessing (robust & iPhone-safe) ----------
    // IMPORTANT: avoids relying on coords.shape[0] synchronously (can be tricky).
    // We compute bbox using reductions (sum along axes).
    function canvasToTensor(){
      return tf.tidy(() => {
        // grayscale 0..1 (white=1)
        const img = tf.browser.fromPixels(canvas, 1).toFloat().div(255.0).squeeze(); // [280,280]
        const ink = img; // –±–µ–ª—ã–µ –ª–∏–Ω–∏–∏ = 1 (—á–µ—Ä–Ω–∏–ª–∞)

        // mask —á–µ—Ä–Ω–∏–ª
        const mask = ink.greater(0.08).toFloat(); // [280,280] 0/1

        // –µ—Å–ª–∏ –ø—É—Å—Ç–æ: sum==0
        const total = mask.sum().dataSync()[0];
        if (total < 1) {
          return tf.zeros([1,28,28,1]);
        }

        // bbox —á–µ—Ä–µ–∑ —Å—É–º–º—ã –ø–æ –æ—Å—è–º
        const rows = mask.sum(1); // [280]
        const cols = mask.sum(0); // [280]

        const rowsArr = rows.dataSync();
        const colsArr = cols.dataSync();

        rows.dispose();
        cols.dispose();

        let ymin = 0, ymax = 279, xmin = 0, xmax = 279;

        // find first/last non-zero
        for(let i=0;i<280;i++){ if(rowsArr[i] > 0){ ymin = i; break; } }
        for(let i=279;i>=0;i--){ if(rowsArr[i] > 0){ ymax = i; break; } }
        for(let i=0;i<280;i++){ if(colsArr[i] > 0){ xmin = i; break; } }
        for(let i=279;i>=0;i--){ if(colsArr[i] > 0){ xmax = i; break; } }

        // crop + padding
        const pad = 14;
        const y0 = Math.max(0, ymin - pad);
        const x0 = Math.max(0, xmin - pad);
        const y1 = Math.min(279, ymax + pad);
        const x1 = Math.min(279, xmax + pad);

        const h = y1 - y0 + 1;
        const w = x1 - x0 + 1;

        let cropped = ink.slice([y0, x0],[h, w]); // [h,w]

        // square pad
        const size = Math.max(h, w);
        const top = Math.floor((size - h)/2);
        const bottom = size - h - top;
        const left = Math.floor((size - w)/2);
        const right = size - w - left;

        cropped = tf.pad(cropped, [[top,bottom],[left,right]]); // [size,size]

        // resize to 28x28
        let resized = tf.image.resizeBilinear(cropped.expandDims(-1), [28,28]); // [28,28,1]
        resized = resized.clipByValue(0,1);
        resized = resized.pow(0.7); // –Ω–µ–±–æ–ª—å—à–æ–π "–∫–æ–Ω—Ç—Ä–∞—Å—Ç"
        return resized.expandDims(0); // [1,28,28,1]
      });
    }

    function predict(){
      try {
        setStatus('–¥—É–º–∞—é‚Ä¶');

        if(!model){
          setStatus('–º–æ–¥–µ–ª—å –Ω–µ –≥–æ—Ç–æ–≤–∞');
          return;
        }

        const x = canvasToTensor();             // [1,28,28,1]
        const y = model.predict(x);             // [1,10]
        const probs = Array.from(y.dataSync()); // [10]

        x.dispose();
        y.dispose();

        const arr = probs.map((p,i)=>({i,p})).sort((a,b)=>b.p-a.p);
        const best = arr[0];
        const top3 = arr.slice(0,3).map(o => `${o.i}:${(o.p*100).toFixed(1)}%`).join('  ');

        setOut(String(best.i), `–£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: ${(best.p*100).toFixed(1)}%`, top3);
        setStatus('–≥–æ—Ç–æ–≤–æ ‚úÖ');
      } catch (e) {
        setStatus('–û—à–∏–±–∫–∞ –≤ —É–≥–∞–¥—ã–≤–∞–Ω–∏–∏: ' + (e?.message || e));
      }
    }

    btnGuess.addEventListener('click', predict);

    // ================== Training Data (MNIST mini) ==================
    async function loadMnistMini(){
      setStatus('–∫–∞—á–∞—é –º–∏–Ω–∏-–¥–∞—Ç–∞—Å–µ—Ç‚Ä¶');

      const IMG_URL   = 'https://storage.googleapis.com/learnjs-data/model-builder/mnist_images.png';
      const LABEL_URL = 'https://storage.googleapis.com/learnjs-data/model-builder/mnist_labels_uint8';

      const img = new Image();
      img.crossOrigin = '';
      img.src = IMG_URL;
      await new Promise((res, rej)=>{ img.onload=res; img.onerror=rej; });

      const labelBuf = await fetch(LABEL_URL).then(r => r.arrayBuffer());
      const labelData = new Uint8Array(labelBuf);

      const NUM = 2200;
      const H = 28, W = 28;

      const CAN = document.createElement('canvas');
      CAN.width = img.width;
      CAN.height = img.height;
      const c = CAN.getContext('2d', { willReadFrequently: true });
      c.drawImage(img, 0, 0);

      const isStrip = (img.width === 28); // –æ–±—ã—á–Ω–æ –¥–∞
      const images = new Float32Array(NUM * H * W);

      if(isStrip){
        for(let i=0;i<NUM;i++){
          const imageData = c.getImageData(0, i*H, W, H).data;
          for(let j=0;j<H*W;j++){
            images[i*H*W + j] = imageData[j*4] / 255;
          }
        }
      } else {
        const perRow = Math.floor(img.width / W);
        for(let i=0;i<NUM;i++){
          const sx = (i % perRow) * W;
          const sy = Math.floor(i / perRow) * H;
          const imageData = c.getImageData(sx, sy, W, H).data;
          for(let j=0;j<H*W;j++){
            images[i*H*W + j] = imageData[j*4] / 255;
          }
        }
      }

      const labels = new Uint8Array(NUM * 10);
      labels.set(labelData.slice(0, NUM*10));

      const TRAIN = 2000;
      const testCount = NUM - TRAIN;

      const xTrain = tf.tensor4d(images.slice(0, TRAIN*H*W), [TRAIN, H, W, 1]);
      const yTrain = tf.tensor2d(labels.slice(0, TRAIN*10), [TRAIN, 10]);

      const xTest = tf.tensor4d(images.slice(TRAIN*H*W), [testCount, H, W, 1]);
      const yTest = tf.tensor2d(labels.slice(TRAIN*10), [testCount, 10]);

      setStatus('–¥–∞—Ç–∞—Å–µ—Ç –≥–æ—Ç–æ–≤');
      return { xTrain, yTrain, xTest, yTest };
    }

    async function train(){
      if(!model) model = buildModel();

      btnTrain.disabled = true;
      btnGuess.disabled = true;
      btnSave.disabled = true;

      let data;
      try{
        data = await loadMnistMini();
      } catch(e){
        console.error(e);
        setStatus('–Ω–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å –¥–∞—Ç–∞—Å–µ—Ç (–ø—Ä–æ–≤–µ—Ä—å –∏–Ω—Ç–µ—Ä–Ω–µ—Ç)');
        btnTrain.disabled = false;
        btnGuess.disabled = false;
        return;
      }

      setStatus('–æ–±—É—á–∞—é‚Ä¶');
      try{
        await model.fit(data.xTrain, data.yTrain, {
          epochs: 10,
          batchSize: 64,
          validationData: [data.xTest, data.yTest],
          callbacks: {
            onEpochEnd: (ep, logs) => {
              const acc = logs?.acc ?? logs?.accuracy ?? 0;
              const val = logs?.val_acc ?? logs?.val_accuracy ?? 0;
              setStatus(`—ç–ø–æ—Ö–∞ ${ep+1}/10 ‚Äî acc ${(acc*100).toFixed(1)}% ‚Äî val ${(val*100).toFixed(1)}%`);
            }
          }
        });
        setStatus('–æ–±—É—á–µ–Ω–∏–µ –≥–æ—Ç–æ–≤–æ ‚úÖ');
        btnSave.disabled = false;
      } finally {
        data.xTrain.dispose(); data.yTrain.dispose();
        data.xTest.dispose();  data.yTest.dispose();
        btnTrain.disabled = false;
        btnGuess.disabled = false;
      }
    }

    btnTrain.addEventListener('click', () => {
      train().catch(e => setStatus('–û—à–∏–±–∫–∞ –æ–±—É—á–µ–Ω–∏—è: ' + (e?.message || e)));
    });

    // ================== Save / Load ==================
    btnSave.addEventListener('click', async () => {
      try{
        if(!model) return;
        setStatus('—Å–æ—Ö—Ä–∞–Ω—è—é –º–æ–¥–µ–ª—å‚Ä¶');
        await model.save('indexeddb://digit-draw-model');
        setStatus('—Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ ‚úÖ');
      } catch(e) {
        setStatus('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: ' + (e?.message || e));
      }
    });

    btnLoad.addEventListener('click', async () => {
      try{
        setStatus('–ø—ã—Ç–∞—é—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –º–æ–¥–µ–ª—å‚Ä¶');
        model = await tf.loadLayersModel('indexeddb://digit-draw-model');
        setStatus('–º–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞ ‚úÖ');
        btnSave.disabled = false;
      } catch(e){
        setStatus('—Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–π –º–æ–¥–µ–ª–∏ –Ω–µ—Ç (–Ω–∞–∂–º–∏ ¬´–û–±—É—á–∏—Ç—å¬ª, –ø–æ—Ç–æ–º ¬´–°–æ—Ö—Ä–∞–Ω–∏—Ç—å¬ª)');
      }
    });

    // ================== Init ==================
    (async () => {
      model = buildModel(); // –≥–æ—Ç–æ–≤–∞, –Ω–æ –Ω–µ –æ–±—É—á–µ–Ω–∞
      setOut('‚Äî','–£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: ‚Äî','‚Äî');
      setStatus('–≥–æ—Ç–æ–≤–æ: —Ä–∏—Å—É–π –∏ –∂–º–∏ ¬´–£–≥–∞–¥–∞—Ç—å¬ª (–¥–ª—è —Ç–æ—á–Ω–æ—Å—Ç–∏ ‚Äî ¬´–û–±—É—á–∏—Ç—å¬ª)');
    })();
  </script>
</body>
</html>
