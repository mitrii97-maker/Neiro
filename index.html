<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>–ò–ò —É—á–∏—Ç—Å—è –æ–±—Ö–æ–¥–∏—Ç—å –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è (Q-learning)</title>
  <style>
    :root { font-family: -apple-system, system-ui, Arial; }
    body { margin:0; background:#0b0d12; color:#e9eefc; }
    .wrap { max-width: 980px; margin: 0 auto; padding: 16px; }
    h1 { margin: 8px 0 6px; font-size: 20px; }
    .sub { margin: 0 0 12px; opacity: .85; line-height: 1.35; }
    .card { background:#111626; border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:14px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:10px 0; }
    button {
      border:0; border-radius:12px; padding:12px 14px; font-weight:800;
      background:#2a6bff; color:#fff;
    }
    button.ghost { background:transparent; border:1px solid rgba(255,255,255,.18); }
    button:disabled { opacity:.45; }

    .grid { display:grid; grid-template-columns: 1.2fr 1fr; gap: 12px; }
    @media (max-width: 860px){ .grid{ grid-template-columns: 1fr; } }

    canvas { width:100%; height:auto; background:#0a0f1c; border-radius:14px; border:1px solid rgba(255,255,255,.12); touch-action:none; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 13px; opacity:.92; }
    .pill { display:inline-block; padding:6px 10px; border:1px solid rgba(255,255,255,.15); border-radius:999px; }
    .bar { height: 10px; background: rgba(255,255,255,.12); border-radius:999px; overflow:hidden; }
    .bar > div { height:100%; width:0%; background:#2a6bff; }
    .legend { display:flex; gap:10px; flex-wrap:wrap; }
    .sw { display:inline-flex; gap:6px; align-items:center; }
    .dot { width:12px; height:12px; border-radius:3px; display:inline-block; border:1px solid rgba(255,255,255,.18); }
  </style>
</head>
<body>
  <main class="wrap">
    <h1>–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è: –ò–ò —É—á–∏—Ç—Å—è –æ–±—Ö–æ–¥–∏—Ç—å –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è</h1>
    <p class="sub">
      –≠—Ç–æ —Ä–µ–∞–ª—å–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ —Å –ø–æ–¥–∫—Ä–µ–ø–ª–µ–Ω–∏–µ–º (Q-learning): –∞–≥–µ–Ω—Ç —Å–Ω–∞—á–∞–ª–∞ —Ç—ã–∫–∞–µ—Ç—Å—è –≤ —Å—Ç–µ–Ω—ã, –ø–æ—Ç–æ–º –Ω–∞—á–∏–Ω–∞–µ—Ç –ø–æ–Ω–∏–º–∞—Ç—å,
      –∫—É–¥–∞ –ª—É—á—à–µ –∏–¥—Ç–∏. –ü—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä —Ä–∞—Å—Ç—ë—Ç, –∫–æ–≥–¥–∞ —Å—Ä–µ–¥–Ω—è—è –¥–ª–∏–Ω–∞ —É—Å–ø–µ—à–Ω–æ–≥–æ –ø—É—Ç–∏ –ø—Ä–∏–±–ª–∏–∂–∞–µ—Ç—Å—è –∫ –∫—Ä–∞—Ç—á–∞–π—à–µ–º—É.
    </p>

    <section class="card">
      <div class="grid">
        <div>
          <canvas id="cv" width="720" height="720"></canvas>
          <div class="row">
            <button id="btnStart">‚ñ∂ –°—Ç–∞—Ä—Ç</button>
            <button id="btnStep" class="ghost">‚è≠ –®–∞–≥</button>
            <button id="btnReset" class="ghost">üîÑ –°–±—Ä–æ—Å</button>
            <button id="btnRandom" class="ghost">üé≤ –ù–æ–≤—ã–π –ª–∞–±–∏—Ä–∏–Ω—Ç</button>
          </div>
          <div class="legend mono">
            <span class="sw"><span class="dot" style="background:#0a0f1c"></span> –ø—É—Å—Ç–æ</span>
            <span class="sw"><span class="dot" style="background:#2b2f3f"></span> —Å—Ç–µ–Ω–∞</span>
            <span class="sw"><span class="dot" style="background:#2a6bff"></span> –∞–≥–µ–Ω—Ç</span>
            <span class="sw"><span class="dot" style="background:#2bd67b"></span> —Ü–µ–ª—å</span>
            <span class="sw"><span class="dot" style="background:#ffcc00"></span> —Å—Ç–∞—Ä—Ç</span>
          </div>
        </div>

        <div>
          <div class="mono">–£—Ä–æ–≤–µ–Ω—å ‚Äú—É–º–Ω–µ–Ω–∏—è‚Äù: <b id="lvl">0%</b></div>
          <div class="bar"><div id="barFill"></div></div>

          <div class="row mono">
            <span class="pill">–≠–ø–∏–∑–æ–¥: <b id="ep">0</b></span>
            <span class="pill">–®–∞–≥ –≤ —ç–ø–∏–∑–æ–¥–µ: <b id="st">0</b></span>
            <span class="pill">–£—Å–ø–µ—Ö–æ–≤: <b id="wins">0</b></span>
          </div>

          <div class="row mono">
            <span class="pill">Œµ (–∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ): <b id="eps">1.00</b></span>
            <span class="pill">–°—Ä–µ–¥–Ω. —à–∞–≥–æ–≤: <b id="avg">‚Äî</b></span>
            <span class="pill">–û–ø—Ç–∏–º—É–º: <b id="opt">‚Äî</b></span>
          </div>

          <div class="row">
            <button id="btnFast" class="ghost">‚ö° –ë—ã—Å—Ç—Ä–µ–µ</button>
            <button id="btnSlow" class="ghost">üê¢ –ú–µ–¥–ª–µ–Ω–Ω–µ–µ</button>
          </div>

          <div class="mono" style="opacity:.85; line-height:1.35;">
            <b>–ö–∞–∫ —á–∏—Ç–∞—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å:</b><br/>
            ‚Ä¢ 0% = –ø–æ—á—Ç–∏ –Ω–µ –¥–æ—Ö–æ–¥–∏—Ç –¥–æ —Ü–µ–ª–∏ –∏–ª–∏ —Ö–æ–¥–∏—Ç –æ—á–µ–Ω—å –¥–æ–ª–≥–æ.<br/>
            ‚Ä¢ 100% = –æ–±—ã—á–Ω–æ –¥–æ—Ö–æ–¥–∏—Ç –∏ –ø—É—Ç—å –±–ª–∏–∑–æ–∫ –∫ –∫—Ä–∞—Ç—á–∞–π—à–µ–º—É.<br/><br/>
            <b>–ü–æ–¥—Å–∫–∞–∑–∫–∞:</b> –Ω–∞–∂–º–∏ ‚Äú‚ö° –ë—ã—Å—Ç—Ä–µ–µ‚Äù, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å ‚Äú—É–º–Ω–µ–Ω–∏–µ‚Äù –±—ã—Å—Ç—Ä–µ–µ.
          </div>
        </div>
      </div>
    </section>
  </main>

<script>
(() => {
  // ======== Grid world settings ========
  const W = 10, H = 10;
  const ACTIONS = 4; // 0 up,1 right,2 down,3 left
  const dirs = [
    {dx:0, dy:-1},
    {dx:1, dy:0},
    {dx:0, dy:1},
    {dx:-1, dy:0}
  ];

  // Rewards
  const R_STEP = -0.04;
  const R_WALL = -1.0;
  const R_GOAL = +10.0;

  // Q-learning hyperparams
  let alpha = 0.25;
  let gamma = 0.95;
  let epsilon = 1.0;
  let epsilonMin = 0.05;
  let epsilonDecay = 0.995;

  // Simulation speed
  let stepsPerFrame = 1;   // can increase
  let playing = false;

  // UI
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');

  const btnStart = document.getElementById('btnStart');
  const btnStep = document.getElementById('btnStep');
  const btnReset = document.getElementById('btnReset');
  const btnRandom = document.getElementById('btnRandom');
  const btnFast = document.getElementById('btnFast');
  const btnSlow = document.getElementById('btnSlow');

  const elLvl = document.getElementById('lvl');
  const elFill = document.getElementById('barFill');
  const elEp = document.getElementById('ep');
  const elSt = document.getElementById('st');
  const elWins = document.getElementById('wins');
  const elEps = document.getElementById('eps');
  const elAvg = document.getElementById('avg');
  const elOpt = document.getElementById('opt');

  // ======== Environment state ========
  let grid = []; // 0 empty, 1 wall
  let start = {x:1, y:8};
  let goal  = {x:8, y:1};

  let agent = {x:start.x, y:start.y};
  let episode = 0;
  let stepInEp = 0;
  let wins = 0;
  let maxSteps = 200;

  // Progress tracking
  const successSteps = []; // store steps to goal for last N successes
  const SUCCESS_WINDOW = 30;
  let optimalSteps = null;

  // Q-table: [H][W][A]
  let Q = null;

  // ======== Helpers ========
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const randInt = (a,b) => Math.floor(Math.random()*(b-a+1))+a;

  function makeEmptyGrid(){
    grid = Array.from({length:H}, () => Array(W).fill(0));
  }

  // Simple maze generator: random walls but keep connectivity (retry)
  function randomMaze(){
    for (let tries=0; tries<50; tries++){
      makeEmptyGrid();
      // outer border optional: keep edges open for simplicity
      const wallCount = randInt(14, 24);
      for (let i=0;i<wallCount;i++){
        const x = randInt(0, W-1);
        const y = randInt(0, H-1);
        if ((x===start.x && y===start.y) || (x===goal.x && y===goal.y)) continue;
        grid[y][x] = 1;
      }
      const opt = bfsShortest(start, goal);
      if (opt != null && opt <= 40){
        optimalSteps = opt;
        return;
      }
    }
    // fallback: fixed walls if random fails
    fixedMaze();
  }

  function fixedMaze(){
    makeEmptyGrid();
    // some walls
    const walls = [
      // vertical-ish
      [3,0],[3,1],[3,2],[3,3],[3,4],
      [6,2],[6,3],[6,4],[6,5],[6,6],
      // horizontal-ish
      [1,6],[2,6],[3,6],[4,6],[5,6],
      [4,8],[5,8],[6,8],[7,8],
      // extra
      [7,3],[8,3],
      [1,2],[2,2]
    ];
    for (const [x,y] of walls){
      if ((x===start.x && y===start.y) || (x===goal.x && y===goal.y)) continue;
      if (x>=0 && x<W && y>=0 && y<H) grid[y][x] = 1;
    }
    optimalSteps = bfsShortest(start, goal);
  }

  function bfsShortest(s, g){
    // returns shortest path length in steps (Manhattan moves), or null
    const q = [];
    const dist = Array.from({length:H},()=>Array(W).fill(-1));
    dist[s.y][s.x]=0;
    q.push(s);
    while(q.length){
      const cur = q.shift();
      if (cur.x===g.x && cur.y===g.y) return dist[cur.y][cur.x];
      for (const d of dirs){
        const nx=cur.x+d.dx, ny=cur.y+d.dy;
        if(nx<0||nx>=W||ny<0||ny>=H) continue;
        if(grid[ny][nx]===1) continue;
        if(dist[ny][nx]!==-1) continue;
        dist[ny][nx]=dist[cur.y][cur.x]+1;
        q.push({x:nx,y:ny});
      }
    }
    return null;
  }

  function resetQ(){
    Q = Array.from({length:H}, () =>
      Array.from({length:W}, () => Array(ACTIONS).fill(0))
    );
  }

  function resetAll(keepMaze=false){
    playing=false;
    btnStart.textContent = '‚ñ∂ –°—Ç–∞—Ä—Ç';

    episode = 0;
    stepInEp = 0;
    wins = 0;

    epsilon = 1.0;
    successSteps.length = 0;

    agent = {x:start.x, y:start.y};

    if (!keepMaze){
      fixedMaze();
    } else {
      optimalSteps = bfsShortest(start, goal);
    }

    resetQ();
    updateUI();
    draw();
  }

  function stateKey(x,y){ return y*W+x; }

  function chooseAction(x,y){
    if (Math.random() < epsilon){
      return randInt(0, ACTIONS-1);
    }
    // greedy with random tie-break
    let best = -Infinity;
    let bestActions = [];
    for (let a=0;a<ACTIONS;a++){
      const v = Q[y][x][a];
      if (v > best + 1e-9){
        best = v;
        bestActions = [a];
      } else if (Math.abs(v - best) <= 1e-9){
        bestActions.push(a);
      }
    }
    return bestActions[randInt(0, bestActions.length-1)];
  }

  function step(){
    // one RL step
    const ax = agent.x, ay = agent.y;
    const a = chooseAction(ax, ay);
    const d = dirs[a];
    const nx = ax + d.dx, ny = ay + d.dy;

    let reward = R_STEP;
    let nextX = ax, nextY = ay;
    let done = false;

    if (nx < 0 || nx >= W || ny < 0 || ny >= H || grid[ny][nx] === 1){
      // hit wall / boundary: stay
      reward = R_WALL;
    } else {
      nextX = nx; nextY = ny;
      if (nextX === goal.x && nextY === goal.y){
        reward = R_GOAL;
        done = true;
      }
    }

    // Q update: Q(s,a) ‚Üê Q(s,a)+Œ±[r+Œ≥ max_a' Q(s',a') - Q(s,a)]
    const oldQ = Q[ay][ax][a];
    let maxNext = -Infinity;
    for (let a2=0;a2<ACTIONS;a2++){
      maxNext = Math.max(maxNext, Q[nextY][nextX][a2]);
    }
    const target = reward + (done ? 0 : gamma * maxNext);
    Q[ay][ax][a] = oldQ + alpha * (target - oldQ);

    // move agent
    agent.x = nextX; agent.y = nextY;
    stepInEp++;

    // episode termination
    if (done || stepInEp >= maxSteps){
      episode++;
      if (done){
        wins++;
        successSteps.push(stepInEp);
        if (successSteps.length > SUCCESS_WINDOW) successSteps.shift();
      }
      // decay epsilon
      epsilon = Math.max(epsilonMin, epsilon * epsilonDecay);
      // reset agent
      agent.x = start.x; agent.y = start.y;
      stepInEp = 0;
    }
  }

  function avg(arr){
    if (!arr.length) return null;
    return arr.reduce((a,b)=>a+b,0)/arr.length;
  }

  function progressPercent(){
    // Based on how close avg successful steps is to optimal.
    // If no successes yet => 0.
    const a = avg(successSteps);
    if (a == null || optimalSteps == null) return 0;

    // map: optimalSteps => 100, maxSteps => ~0
    const worst = Math.max(optimalSteps + 1, Math.min(maxSteps, optimalSteps + 60));
    const p = 1 - ((a - optimalSteps) / (worst - optimalSteps));
    return Math.round(clamp(p, 0, 1) * 100);
  }

  function updateUI(){
    elEp.textContent = String(episode);
    elSt.textContent = String(stepInEp);
    elWins.textContent = String(wins);
    elEps.textContent = epsilon.toFixed(2);

    const a = avg(successSteps);
    elAvg.textContent = a == null ? '‚Äî' : a.toFixed(1);
    elOpt.textContent = optimalSteps == null ? '‚Äî' : String(optimalSteps);

    const p = progressPercent();
    elLvl.textContent = p + '%';
    elFill.style.width = p + '%';
  }

  function draw(){
    const cw = cv.width, ch = cv.height;
    ctx.clearRect(0,0,cw,ch);

    const pad = 18;
    const size = Math.min(cw, ch) - pad*2;
    const cell = size / W;

    // background
    ctx.fillStyle = '#0a0f1c';
    ctx.fillRect(0,0,cw,ch);

    // grid cells
    for (let y=0;y<H;y++){
      for (let x=0;x<W;x++){
        const px = pad + x*cell;
        const py = pad + y*cell;

        // cell base
        ctx.fillStyle = '#0a0f1c';
        ctx.fillRect(px,py,cell,cell);

        // walls
        if (grid[y][x] === 1){
          ctx.fillStyle = '#2b2f3f';
          ctx.fillRect(px,py,cell,cell);
        }

        // border lines
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.strokeRect(px,py,cell,cell);
      }
    }

    // start & goal
    {
      const sx = pad + start.x*cell, sy = pad + start.y*cell;
      ctx.fillStyle = '#ffcc00';
      ctx.fillRect(sx+cell*0.18, sy+cell*0.18, cell*0.64, cell*0.64);
    }
    {
      const gx = pad + goal.x*cell, gy = pad + goal.y*cell;
      ctx.fillStyle = '#2bd67b';
      ctx.fillRect(gx+cell*0.18, gy+cell*0.18, cell*0.64, cell*0.64);
    }

    // agent
    {
      const ax = pad + agent.x*cell, ay = pad + agent.y*cell;
      ctx.fillStyle = '#2a6bff';
      ctx.beginPath();
      ctx.arc(ax + cell/2, ay + cell/2, cell*0.28, 0, Math.PI*2);
      ctx.fill();
    }

    // title overlay
    ctx.fillStyle = 'rgba(233,238,252,0.8)';
    ctx.font = '16px -apple-system, system-ui, Arial';
    ctx.fillText(`steps/frame: ${stepsPerFrame}`, 18, 22);
  }

  function tick(){
    if (playing){
      for (let i=0;i<stepsPerFrame;i++) step();
      updateUI();
      draw();
    }
    requestAnimationFrame(tick);
  }

  // ======== UI handlers ========
  btnStart.addEventListener('click', () => {
    playing = !playing;
    btnStart.textContent = playing ? '‚è∏ –ü–∞—É–∑–∞' : '‚ñ∂ –°—Ç–∞—Ä—Ç';
  });

  btnStep.addEventListener('click', () => {
    // do a little burst so it's visible
    for (let i=0;i<20;i++) step();
    updateUI();
    draw();
  });

  btnReset.addEventListener('click', () => {
    resetAll(true); // keep maze, reset learning
  });

  btnRandom.addEventListener('click', () => {
    playing = false;
    btnStart.textContent = '‚ñ∂ –°—Ç–∞—Ä—Ç';
    randomMaze();
    resetQ();
    agent = {x:start.x, y:start.y};
    episode = 0; stepInEp = 0; wins = 0; epsilon = 1.0; successSteps.length = 0;
    updateUI();
    draw();
  });

  btnFast.addEventListener('click', () => {
    stepsPerFrame = Math.min(500, stepsPerFrame * 2);
    draw();
  });

  btnSlow.addEventListener('click', () => {
    stepsPerFrame = Math.max(1, Math.floor(stepsPerFrame / 2));
    draw();
  });

  // ======== Init ========
  fixedMaze();
  resetAll(true);
  tick();
})();
</script>
</body>
</html>
