<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>–ö—Ä–∞—Å–Ω—ã–µ vs –°–∏–Ω–∏–µ ‚Äî –æ–±—É—á–µ–Ω–∏–µ –∞—Ç–∞–∫–∏ –∏ –∑–∞—â–∏—Ç—ã</title>
  <style>
    :root { font-family: -apple-system, system-ui, Arial; }
    body { margin:0; background:#0b0d12; color:#e9eefc; }
    .wrap { max-width: 1180px; margin: 0 auto; padding: 16px; }
    h1 { margin: 8px 0 6px; font-size: 20px; }
    .sub { margin: 0 0 12px; opacity:.85; line-height:1.35; }
    .card { background:#111626; border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:14px; }
    .grid { display:grid; grid-template-columns: 1.25fr 1fr; gap:12px; }
    @media (max-width: 980px){ .grid { grid-template-columns: 1fr; } }

    canvas { width:100%; height:auto; background:#0a0f1c; border-radius:14px; border:1px solid rgba(255,255,255,.12); }

    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:10px 0; }
    button{
      border:0; border-radius:12px; padding:12px 14px; font-weight:900;
      background:#2a6bff; color:#fff;
    }
    button.ghost { background:transparent; border:1px solid rgba(255,255,255,.18); }
    button:disabled { opacity:.45; }

    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 13px; opacity:.92; }
    .pill { display:inline-block; padding:6px 10px; border:1px solid rgba(255,255,255,.15); border-radius:999px; }

    .bar { height: 10px; background: rgba(255,255,255,.12); border-radius:999px; overflow:hidden; }
    .bar > div { height:100%; width:0%; background:#2a6bff; }
    .barRed > div { background:#ff3b30; }
    .barBlue > div { background:#2a6bff; }

    .panelTitle { margin: 2px 0 8px; font-weight:900; }
    .small { font-size: 12px; opacity:.8; }
    .legend { display:flex; gap:10px; flex-wrap:wrap; }
    .sw { display:inline-flex; gap:6px; align-items:center; }
    .dot { width:12px; height:12px; border-radius:4px; display:inline-block; border:1px solid rgba(255,255,255,.18); }

    .box {
      padding: 10px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
    }
    input[type="range"]{ width: 220px; }
  </style>
</head>
<body>
  <main class="wrap">
    <h1>–ö—Ä–∞—Å–Ω—ã–µ vs –°–∏–Ω–∏–µ ‚Äî –æ–±—É—á–µ–Ω–∏–µ –∞—Ç–∞–∫–∏ –∏ –∑–∞—â–∏—Ç—ã</h1>
    <p class="sub">
      –ö—Ä–∞—Å–Ω—ã–µ —É—á–∞—Ç—Å—è –≤—ã–±–∏—Ä–∞—Ç—å –≤—Ö–æ–¥ (–∫–∞–∫–æ–π —á–∞—â–µ –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ –ø—Ä–æ—Ä—ã–≤—É). –°–∏–Ω–∏–µ —É—á–∞—Ç—Å—è, –∫—É–¥–∞ –∏–¥—ë—Ç –¥–∞–≤–ª–µ–Ω–∏–µ, –∏ —É—Å–∏–ª–∏–≤–∞—é—Ç —ç—Ç–∏ –≤—Ö–æ–¥—ã –±–∞—Ä—Ä–∏–∫–∞–¥–∞–º–∏.
      –ë–∞—Ä—Ä–∏–∫–∞–¥—ã –º–æ–∂–Ω–æ –ª–æ–º–∞—Ç—å –∏ —á–∏–Ω–∏—Ç—å ‚Äî –ø–æ—ç—Ç–æ–º—É —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ ‚Äú–ø–ª–∞–≤–∞—é—Ç‚Äù –∏ —ç—Ç–æ –≤–∏–¥–Ω–æ.
    </p>

    <section class="card">
      <div class="grid">
        <div>
          <canvas id="cv" width="980" height="980"></canvas>

          <div class="row">
            <button id="btnStart">‚ñ∂ –°—Ç–∞—Ä—Ç</button>
            <button id="btnReset" class="ghost">üîÑ –°–±—Ä–æ—Å</button>
            <button id="btnFast" class="ghost">‚ö° –ë—ã—Å—Ç—Ä–µ–µ</button>
            <button id="btnSlow" class="ghost">üê¢ –ú–µ–¥–ª–µ–Ω–Ω–µ–µ</button>
          </div>

          <div class="legend mono">
            <span class="sw"><span class="dot" style="background:#2b2f3f"></span> —Å—Ç–µ–Ω—ã</span>
            <span class="sw"><span class="dot" style="background:#ffd60a"></span> –≤—Ö–æ–¥—ã</span>
            <span class="sw"><span class="dot" style="background:#a3a3a3"></span> –±–∞—Ä—Ä–∏–∫–∞–¥—ã</span>
            <span class="sw"><span class="dot" style="background:#2a6bff"></span> —Å–∏–Ω–∏–µ</span>
            <span class="sw"><span class="dot" style="background:#ff3b30"></span> –∫—Ä–∞—Å–Ω—ã–µ</span>
            <span class="sw"><span class="dot" style="background:#7c3aed"></span> —è–¥—Ä–æ</span>
          </div>
        </div>

        <div>
          <div class="panelTitle">–ü—Ä–æ–≥—Ä–µ—Å—Å</div>

          <div class="mono">–ö—Ä–∞—Å–Ω—ã–µ (–ø—Ä–æ—Ä—ã–≤—ã): <b id="rPct">0%</b></div>
          <div class="bar barRed"><div id="rBar"></div></div>

          <div style="height:10px"></div>

          <div class="mono">–°–∏–Ω–∏–µ (—Å–¥–µ—Ä–∂–∏–≤–∞–Ω–∏–µ): <b id="bPct">0%</b></div>
          <div class="bar barBlue"><div id="bBar"></div></div>

          <div class="row mono">
            <span class="pill">–¢–∏–∫: <b id="tick">0</b></span>
            <span class="pill">–ö—Ä–∞—Å–Ω—ã—Ö: <b id="rN">0</b></span>
            <span class="pill">–°–∏–Ω–∏—Ö: <b id="bN">0</b></span>
            <span class="pill">–ë–∞—Ä—Ä–∏–∫–∞–¥: <b id="barN">0</b></span>
          </div>

          <div class="row mono">
            <span class="pill">–ê—Ç–∞–∫–∏ (–æ–∫–Ω–æ): <b id="attW">0</b></span>
            <span class="pill">–ü—Ä–æ—Ä—ã–≤—ã (–æ–∫–Ω–æ): <b id="succW">0</b></span>
            <span class="pill">–ë–ª–æ–∫–∏ (–æ–∫–Ω–æ): <b id="blockW">0</b></span>
            <span class="pill">–†–µ–º–æ–Ω—Ç—ã (–æ–∫–Ω–æ): <b id="repW">0</b></span>
          </div>

          <div class="panelTitle">–ì—Ä–∞—Ñ–∏–∫ (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 80)</div>
          <canvas id="spark" width="560" height="140" class="box"></canvas>
          <div class="small mono">–ö—Ä–∞—Å–Ω–∞—è –ª–∏–Ω–∏—è = % –ø—Ä–æ—Ä—ã–≤–æ–≤, —Å–∏–Ω—è—è –ª–∏–Ω–∏—è = % —Å–¥–µ—Ä–∂–∏–≤–∞–Ω–∏—è</div>

          <div class="panelTitle" style="margin-top:14px;">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</div>
          <div class="box mono">
            <div class="row" style="margin:0;">
              <span>–°–ª–æ–∂–Ω–æ—Å—Ç—å:</span>
              <input id="diff" type="range" min="0" max="100" value="55" />
              <span class="pill" id="diffLabel">55</span>
            </div>
            <div class="small" style="margin-top:8px; opacity:.85; line-height:1.35;">
              –°–ª–æ–∂–Ω–æ—Å—Ç—å –≤–ª–∏—è–µ—Ç –Ω–∞ —Å–∫–æ—Ä–æ—Å—Ç—å —Å–ø–∞–≤–Ω–∞ –∫—Ä–∞—Å–Ω—ã—Ö, HP –±–∞—Ä—Ä–∏–∫–∞–¥ –∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–∏–Ω–∏—Ö —Ä–µ–º–æ–Ω—Ç–Ω–∏–∫–æ–≤.
            </div>
          </div>

          <div class="panelTitle" style="margin-top:14px;">–ö—É–¥–∞ –ª–µ–∑—É—Ç –∫—Ä–∞—Å–Ω—ã–µ</div>
          <div class="mono" id="prefLine">N/E/S/W: ‚Äî</div>
        </div>
      </div>
    </section>
  </main>

<script>
(() => {
  // ===================== UI =====================
  const $ = (id) => document.getElementById(id);

  const cv = $('cv');
  const ctx = cv.getContext('2d');

  const spark = $('spark');
  const sp = spark.getContext('2d');

  const btnStart = $('btnStart');
  const btnReset = $('btnReset');
  const btnFast  = $('btnFast');
  const btnSlow  = $('btnSlow');

  const elTick = $('tick');
  const elRN = $('rN');
  const elBN = $('bN');
  const elBarN = $('barN');

  const elAttW = $('attW');
  const elSuccW = $('succW');
  const elBlockW = $('blockW');
  const elRepW = $('repW');

  const rPct = $('rPct');
  const bPct = $('bPct');
  const rBar = $('rBar');
  const bBar = $('bBar');

  const diff = $('diff');
  const diffLabel = $('diffLabel');
  const prefLine = $('prefLine');

  // ===================== Helpers =====================
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const randInt = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
  const key = (x,y)=>x+','+y;

  // ===================== World =====================
  const W = 41, H = 41;
  const EMPTY = 0, WALL = 1;

  const base = { x0: 13, y0: 13, x1: 27, y1: 27 };
  const core = { x: 20, y: 20 };

  const entrances = [
    { name:'N', ex:20, ey:13, tx:20, ty:2  },
    { name:'E', ex:27, ey:20, tx:38, ty:20 },
    { name:'S', ex:20, ey:27, tx:20, ty:38 },
    { name:'W', ex:13, ey:20, tx:2,  ty:20 },
  ];

  let grid = [];
  // barricades on entrance tiles only: key(ex,ey) -> {hp, hpMax}
  let barricades = new Map();

  // agents
  let reds = [];   // {x,y, ent, path, life, stuck, cooldown}
  let blues = [];  // {x,y, role, ent}

  // ===================== Learning =====================
  // red values for entrances
  let Qent = [0,0,0,0];
  let temperature = 1.0;
  let lrRed = 0.10;

  // blue pressure per entrance
  let pressure = [0,0,0,0];  // EMA of attacks
  let threat   = [0,0,0,0];  // EMA of hits on barricades
  let lrBlue = 0.08;

  // ===================== Metrics =====================
  const WIN = 220;
  let wAtt=[], wSucc=[], wBlock=[], wRep=[];
  const pushWin = (arr,v)=>{ arr.push(v); if(arr.length>WIN) arr.shift(); };
  const sum = (arr)=>arr.reduce((a,b)=>a+b,0);

  const HIST = 80;
  let histR=[], histB=[];

  // ===================== Simulation =====================
  let tick = 0;
  let playing = false;
  let stepsPerFrame = 2;

  function difficultyValue(){ return Number(diff.value); }

  // ===================== Map build =====================
  function makeEmpty(){
    grid = Array.from({length:H},()=>Array(W).fill(EMPTY));
    barricades.clear();
  }

  function buildMap(){
    makeEmpty();

    // border walls
    for(let x=0;x<W;x++){ grid[0][x]=WALL; grid[H-1][x]=WALL; }
    for(let y=0;y<H;y++){ grid[y][0]=WALL; grid[y][W-1]=WALL; }

    // base walls square
    for(let x=base.x0; x<=base.x1; x++){
      grid[base.y0][x]=WALL;
      grid[base.y1][x]=WALL;
    }
    for(let y=base.y0; y<=base.y1; y++){
      grid[y][base.x0]=WALL;
      grid[y][base.x1]=WALL;
    }

    // carve entrances
    for(const e of entrances){
      grid[e.ey][e.ex]=EMPTY;
    }

    // tunnels
    for(const e of entrances){
      const dx = Math.sign(e.tx - e.ex);
      const dy = Math.sign(e.ty - e.ey);
      let x=e.ex, y=e.ey;
      while(x!==e.tx || y!==e.ty){
        x+=dx; y+=dy;
        if(x<=0||x>=W-1||y<=0||y>=H-1) break;
        grid[y][x]=EMPTY;
      }
    }

    // interior obstacles (random, –Ω–æ –Ω–µ —Å–ª–∏—à–∫–æ–º)
    const D = difficultyValue();
    const obs = 10 + Math.floor(D/3); // 10..43
    for(let i=0;i<obs;i++){
      const x=randInt(base.x0+1, base.x1-1);
      const y=randInt(base.y0+1, base.y1-1);
      if(x===core.x && y===core.y) continue;
      // –Ω–µ —Å—Ç–∞–≤–∏–º –ø—Ä—è–º–æ —É –≤—Ö–æ–¥–æ–≤ –≤–Ω—É—Ç—Ä–∏
      let near=false;
      for(const e of entrances){
        const ix = clamp(e.ex + Math.sign(core.x - e.ex), base.x0+1, base.x1-1);
        const iy = clamp(e.ey + Math.sign(core.y - e.ey), base.y0+1, base.y1-1);
        if(Math.abs(x-ix)+Math.abs(y-iy)<=1){ near=true; break; }
      }
      if(near) continue;
      grid[y][x]=WALL;
    }

    grid[core.y][core.x]=EMPTY;
  }

  // ===================== Pathfinding (A*) =====================
  function isBlocked(x,y){
    if(x<0||x>=W||y<0||y>=H) return true;
    if(grid[y][x]===WALL) return true;
    if(barricades.has(key(x,y))) return true; // only entrance tile can have
    return false;
  }

  function astar(sx,sy,gx,gy, maxIter=7000){
    const startK = key(sx,sy);
    const goalK  = key(gx,gy);

    const open = new Map();  // k -> f
    const gScore = new Map();
    const came = new Map();
    const h = (x,y)=>Math.abs(x-gx)+Math.abs(y-gy);

    open.set(startK, h(sx,sy));
    gScore.set(startK, 0);

    let iter=0;
    while(open.size && iter++<maxIter){
      let curK=null, bestF=Infinity;
      for(const [k,f] of open){
        if(f<bestF){ bestF=f; curK=k; }
      }
      if(curK===goalK){
        const path=[];
        let k=curK;
        while(k!==startK){
          const [x,y]=k.split(',').map(Number);
          path.push({x,y});
          k=came.get(k);
          if(!k) break;
        }
        path.reverse();
        return path;
      }

      open.delete(curK);
      const [cx,cy]=curK.split(',').map(Number);
      const cg = gScore.get(curK) ?? Infinity;

      const neigh = [
        {x:cx+1,y:cy},{x:cx-1,y:cy},{x:cx,y:cy+1},{x:cx,y:cy-1}
      ];
      for(const n of neigh){
        if(isBlocked(n.x,n.y)) continue;
        const nk = key(n.x,n.y);
        const ng = cg + 1;
        const old = gScore.get(nk);
        if(old===undefined || ng<old){
          came.set(nk, curK);
          gScore.set(nk, ng);
          open.set(nk, ng + h(n.x,n.y));
        }
      }
    }
    return null;
  }

  // ===================== Red policy (softmax) =====================
  function softmaxProbs(vals){
    const t = temperature;
    const exps = vals.map(v => Math.exp(v / t));
    const s = exps.reduce((a,b)=>a+b,0) || 1;
    return exps.map(e => e/s);
  }

  function pickEntrance(){
    const p = softmaxProbs(Qent);
    let r = Math.random();
    for(let i=0;i<p.length;i++){
      r -= p[i];
      if(r<=0) return i;
    }
    return p.length-1;
  }

  function updateRed(ent, reward){
    // EMA update: fast adaptation
    Qent[ent] = Qent[ent] + lrRed * (reward - Qent[ent]);
    // keep bounded
    Qent[ent] = clamp(Qent[ent], -2.5, 2.5);
  }

  // ===================== Spawning =====================
  function spawnRed(){
    const D = difficultyValue();
    const ent = pickEntrance();
    const e = entrances[ent];

    // record attack & pressure
    pressure[ent] = (1-lrBlue)*pressure[ent] + lrBlue*1;

    let sx = clamp(e.tx + randInt(-1,1), 1, W-2);
    let sy = clamp(e.ty + randInt(-1,1), 1, H-2);
    if(grid[sy][sx]===WALL) return;

    const path = astar(sx,sy, core.x,core.y) || [];
    reds.push({
      x:sx, y:sy, ent,
      path,
      life: 230 + randInt(0,90) - Math.floor(D/5),
      stuck: 0,
      cooldown: 0
    });

    pushWin(wAtt,1);
    pushWin(wSucc,0);
    pushWin(wBlock,0);
    pushWin(wRep,0);
  }

  function resetAgents(){
    reds=[];
    blues=[];
    const D = difficultyValue();
    const blueCount = 6 + Math.floor(D/20);
    for(let i=0;i<blueCount;i++){
      blues.push({
        x: randInt(base.x0+2, base.x1-2),
        y: randInt(base.y0+2, base.y1-2),
        role: (i%3===0 ? 'repair' : 'patrol'),
        ent: randInt(0,3)
      });
    }
  }

  // ===================== Blue defense =====================
  function ensureBarricade(entIdx){
    const D = difficultyValue();
    const e = entrances[entIdx];
    const k = key(e.ex,e.ey);

    const baseHp = 10 + Math.floor(D/8); // 10..22
    if(!barricades.has(k)){
      barricades.set(k, { hp: baseHp, hpMax: baseHp });
      return;
    }
    // refresh a bit (soft reinforce)
    const b = barricades.get(k);
    b.hpMax = Math.max(b.hpMax, baseHp);
  }

  function blueStep(){
    const D = difficultyValue();

    // decay
    for(let i=0;i<4;i++){
      pressure[i]*=0.995;
      threat[i]*=0.994;
    }

    // choose entrance scores
    const score = [0,1,2,3].map(i => ({
      i,
      s: pressure[i]*1.0 + threat[i]*1.5
    })).sort((a,b)=>b.s-a.s);

    // budget of barricades
    const budget = 2 + Math.floor(D/35); // 2..4
    for(let j=0;j<budget;j++){
      ensureBarricade(score[j].i);
    }

    // blue movement + repairs
    for(const b of blues){
      // sometimes retarget to most threatened
      if(Math.random()<0.05) b.ent = score[0].i;

      const e = entrances[b.ent];
      const ix = clamp(e.ex + Math.sign(core.x - e.ex), base.x0+1, base.x1-1);
      const iy = clamp(e.ey + Math.sign(core.y - e.ey), base.y0+1, base.y1-1);

      // move one step toward target
      const tx = (b.role==='patrol') ? core.x : ix;
      const ty = (b.role==='patrol') ? core.y : iy;

      const dx = Math.sign(tx - b.x);
      const dy = Math.sign(ty - b.y);
      const chooseX = Math.random()<0.55;

      let nx = b.x + (chooseX ? dx : 0);
      let ny = b.y + (!chooseX ? dy : 0);

      if(!isBlocked(nx,ny) && !(nx===core.x && ny===core.y)){
        b.x=nx; b.y=ny;
      } else {
        // try other axis
        if(!isBlocked(b.x+dx,b.y) && !((b.x+dx)===core.x && b.y===core.y)) b.x += dx;
        else if(!isBlocked(b.x,b.y+dy) && !(b.x===core.x && (b.y+dy)===core.y)) b.y += dy;
      }

      // repair if near entrance inner cell and barricade exists
      if(b.role==='repair'){
        const bk = key(e.ex,e.ey);
        const barr = barricades.get(bk);
        if(barr && (Math.abs(b.x-ix)+Math.abs(b.y-iy)<=1) && barr.hp < barr.hpMax){
          const rep = 1 + Math.floor(D/60);
          barr.hp = Math.min(barr.hpMax, barr.hp + rep);
          pushWin(wRep,1);
        } else {
          pushWin(wRep,0);
        }
      } else {
        pushWin(wRep,0);
      }
    }

    // slowly regenerate weak barricades a tiny bit (passive maintenance)
    for(const [k,b] of barricades){
      if(b.hp < b.hpMax && Math.random()<0.05){
        b.hp = Math.min(b.hpMax, b.hp + 1);
      }
    }
  }

  // ===================== Red step =====================
  function redStep(r){
    const D = difficultyValue();
    r.life--;
    if(r.life<=0){
      updateRed(r.ent, -0.6);
      return 'dead';
    }

    if(r.x===core.x && r.y===core.y){
      updateRed(r.ent, +1.0);
      return 'success';
    }

    if(!r.path || r.path.length===0 || Math.random()<0.04){
      r.path = astar(r.x,r.y, core.x,core.y) || [];
    }

    if(r.path.length){
      const n = r.path[0];

      // barricade hit
      const bk = key(n.x,n.y);
      if(barricades.has(bk)){
        pushWin(wBlock,1);
        threat[r.ent] = (1-lrBlue)*threat[r.ent] + lrBlue*1;

        updateRed(r.ent, -0.12);

        const barr = barricades.get(bk);
        if(r.cooldown<=0){
          const dmg = 1 + Math.floor(D/70);
          barr.hp -= dmg;
          r.cooldown = 2;
          if(barr.hp <= 0){
            barricades.delete(bk);
            updateRed(r.ent, +0.10); // broke through
          }
        } else {
          r.cooldown--;
        }

        r.stuck++;
        return 'ok';
      }

      if(isBlocked(n.x,n.y)){
        r.path = [];
        r.stuck++;
        updateRed(r.ent, -0.06);
        pushWin(wBlock,0);
        return 'ok';
      }

      // move
      r.x = n.x; r.y = n.y;
      r.path.shift();
      pushWin(wBlock,0);

      // shaping reward: closer to core
      const dist = Math.abs(r.x-core.x)+Math.abs(r.y-core.y);
      updateRed(r.ent, dist<10 ? +0.02 : +0.005);

      r.stuck = Math.max(0, r.stuck - 1);
      return 'ok';
    }

    // wander fallback
    const ds=[{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
    const d=ds[randInt(0,3)];
    const nx=r.x+d.x, ny=r.y+d.y;
    if(!isBlocked(nx,ny)){ r.x=nx; r.y=ny; }
    r.stuck++;
    updateRed(r.ent, -0.02);
    pushWin(wBlock,0);
    return 'ok';
  }

  // ===================== Draw =====================
  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  function draw(){
    const cw=cv.width, ch=cv.height;
    ctx.clearRect(0,0,cw,ch);

    const pad=20;
    const size=Math.min(cw,ch)-pad*2;
    const cell=size/W;

    // background
    ctx.fillStyle='#0a0f1c';
    ctx.fillRect(0,0,cw,ch);

    // walls
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        if(grid[y][x]!==WALL) continue;
        const px=pad+x*cell;
        const py=pad+y*cell;
        ctx.fillStyle='#2b2f3f';
        roundRect(px+cell*0.08,py+cell*0.08,cell*0.84,cell*0.84,cell*0.18);
        ctx.fill();
      }
    }

    // entrances
    for(const e of entrances){
      const px=pad+e.ex*cell;
      const py=pad+e.ey*cell;
      ctx.fillStyle='#ffd60a';
      roundRect(px+cell*0.16,py+cell*0.16,cell*0.68,cell*0.68,cell*0.22);
      ctx.fill();
    }

    // barricades
    for(const [k,b] of barricades){
      const [x,y]=k.split(',').map(Number);
      const px=pad+x*cell;
      const py=pad+y*cell;
      ctx.fillStyle='#a3a3a3';
      roundRect(px+cell*0.12,py+cell*0.12,cell*0.76,cell*0.76,cell*0.18);
      ctx.fill();

      // hp bar
      ctx.fillStyle='rgba(0,0,0,0.35)';
      ctx.fillRect(px+cell*0.12, py+cell*0.06, cell*0.76, cell*0.07);
      ctx.fillStyle='#ffffff';
      ctx.fillRect(px+cell*0.12, py+cell*0.06, cell*0.76*(b.hp/Math.max(1,b.hpMax)), cell*0.07);
    }

    // core
    {
      const px=pad+core.x*cell;
      const py=pad+core.y*cell;
      ctx.fillStyle='#7c3aed';
      roundRect(px+cell*0.18,py+cell*0.18,cell*0.64,cell*0.64,cell*0.22);
      ctx.fill();
    }

    // blues (triangle shield)
    for(const b of blues){
      const cx=pad+b.x*cell+cell/2;
      const cy=pad+b.y*cell+cell/2;
      ctx.fillStyle='#2a6bff';
      ctx.beginPath();
      ctx.moveTo(cx, cy - cell*0.26);
      ctx.lineTo(cx + cell*0.22, cy + cell*0.18);
      ctx.lineTo(cx - cell*0.22, cy + cell*0.18);
      ctx.closePath();
      ctx.fill();
    }

    // reds (arrow)
    for(const r of reds){
      const cx=pad+r.x*cell+cell/2;
      const cy=pad+r.y*cell+cell/2;
      ctx.fillStyle='#ff3b30';
      ctx.beginPath();
      ctx.moveTo(cx + cell*0.26, cy);
      ctx.lineTo(cx - cell*0.18, cy - cell*0.18);
      ctx.lineTo(cx - cell*0.18, cy + cell*0.18);
      ctx.closePath();
      ctx.fill();
    }

    // overlay text
    ctx.fillStyle='rgba(233,238,252,0.86)';
    ctx.font='14px ui-monospace, Menlo, monospace';
    ctx.fillText(`steps/frame: ${stepsPerFrame}   temp: ${temperature.toFixed(2)}`, 18, 22);
  }

  // ===================== Sparkline =====================
  function drawSpark(){
    const w=spark.width, h=spark.height;
    sp.clearRect(0,0,w,h);
    sp.fillStyle='rgba(255,255,255,0.02)';
    sp.fillRect(0,0,w,h);

    sp.strokeStyle='rgba(255,255,255,0.10)';
    for(let i=1;i<4;i++){
      const y=(h*i)/4;
      sp.beginPath(); sp.moveTo(0,y); sp.lineTo(w,y); sp.stroke();
    }

    const drawLine=(arr, color)=>{
      if(arr.length<2) return;
      sp.strokeStyle=color;
      sp.lineWidth=2;
      sp.beginPath();
      for(let i=0;i<arr.length;i++){
        const x=(i/(HIST-1))*w;
        const y=h - (arr[i]/100)*h;
        if(i===0) sp.moveTo(x,y); else sp.lineTo(x,y);
      }
      sp.stroke();
    };

    drawLine(histR,'#ff3b30');
    drawLine(histB,'#2a6bff');
  }

  // ===================== UI update =====================
  function updateUI(){
    diffLabel.textContent = String(difficultyValue());

    elTick.textContent = String(tick);
    elRN.textContent = String(reds.length);
    elBN.textContent = String(blues.length);
    elBarN.textContent = String(barricades.size);

    const att = sum(wAtt);
    const suc = sum(wSucc);
    const blk = sum(wBlock);
    const rep = sum(wRep);

    elAttW.textContent = String(att);
    elSuccW.textContent = String(suc);
    elBlockW.textContent = String(blk);
    elRepW.textContent = String(rep);

    const redRate = att>0 ? (suc/att) : 0;
    const rP = Math.round(redRate*100);

    // blue proxy: blocks+repairs relative to attacks
    const blueRate = att>0 ? clamp((blk*0.30 + rep*0.80)/(att*2.2), 0, 1) : 0;
    const bP = Math.round(blueRate*100);

    rPct.textContent = rP + '%';
    bPct.textContent = bP + '%';
    rBar.style.width = rP + '%';
    bBar.style.width = bP + '%';

    // history
    histR.push(rP); if(histR.length>HIST) histR.shift();
    histB.push(bP); if(histB.length>HIST) histB.shift();
    drawSpark();

    // show entrance probs
    const p = softmaxProbs(Qent);
    prefLine.textContent = `N/E/S/W: ${p.map(x => (x*100).toFixed(0)+'%').join('  ')}   |  Q: ${Qent.map(v=>v.toFixed(2)).join('  ')}`;
  }

  // ===================== Main loop =====================
  function simStep(){
    tick++;
    const D = difficultyValue();

    // spawn control
    const spawnRate = 0.16 + (D/100)*0.24; // 0.16..0.40
    const maxR = 34 + Math.floor(D/8);
    if(reds.length < maxR && Math.random() < spawnRate){
      spawnRed();
    }

    // blue
    blueStep();

    // red
    const alive=[];
    for(const r of reds){
      const res = redStep(r);
      if(res==='success'){
        pushWin(wSucc,1);
        // remove on success
      } else if(res==='dead'){
        // remove
      } else {
        alive.push(r);
      }
    }
    reds = alive;

    // temperature cool -> more ‚Äú—É–≤–µ—Ä–µ–Ω–Ω–∞—è‚Äù —Å—Ç—Ä–∞—Ç–µ–≥–∏—è
    temperature = clamp(temperature * 0.9996, 0.55, 1.15);

    updateUI();
    draw();
  }

  function frame(){
    if(playing){
      for(let i=0;i<stepsPerFrame;i++) simStep();
    }
    requestAnimationFrame(frame);
  }

  // ===================== Controls =====================
  btnStart.addEventListener('click', ()=>{
    playing = !playing;
    btnStart.textContent = playing ? '‚è∏ –ü–∞—É–∑–∞' : '‚ñ∂ –°—Ç–∞—Ä—Ç';
  });

  btnReset.addEventListener('click', ()=>{
    resetAll();
  });

  btnFast.addEventListener('click', ()=>{
    stepsPerFrame = Math.min(80, stepsPerFrame*2);
  });

  btnSlow.addEventListener('click', ()=>{
    stepsPerFrame = Math.max(1, Math.floor(stepsPerFrame/2));
  });

  diff.addEventListener('input', ()=>{
    diffLabel.textContent = String(difficultyValue());
  });

  // ===================== Reset =====================
  function resetLearning(){
    Qent=[0,0,0,0];
    pressure=[0,0,0,0];
    threat=[0,0,0,0];
    temperature=1.0;

    wAtt=[]; wSucc=[]; wBlock=[]; wRep=[];
    histR=[]; histB=[];
    tick=0;
  }

  function resetAll(){
    playing=false;
    btnStart.textContent='‚ñ∂ –°—Ç–∞—Ä—Ç';

    buildMap();
    resetLearning();
    resetAgents();

    updateUI();
    draw();
  }

  // init
  resetAll();
  frame();
})();
</script>
</body>
</html>
