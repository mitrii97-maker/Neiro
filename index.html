<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä—É–∫–æ–ø–∏—Å–Ω—ã—Ö —Ü–∏—Ñ—Ä (0‚Äì9)</title>
  <style>
    :root { font-family: -apple-system, system-ui, Arial; }
    body { margin:0; background:#0b0d12; color:#e9eefc; }
    .wrap { max-width: 920px; margin: 0 auto; padding: 18px; }
    h1 { margin: 10px 0 6px; font-size: 24px; }
    .sub { margin: 0 0 12px; opacity:.8; line-height:1.35; }
    .card { background:#111626; border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:14px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:10px 0; }
    button { border:0; border-radius:12px; padding:12px 14px; font-weight:700; background:#2a6bff; color:#fff; }
    button.ghost { background:transparent; border:1px solid rgba(255,255,255,.18); }
    button:disabled { opacity:.4; }
    .canvasWrap { display:flex; gap:12px; flex-wrap:wrap; align-items:flex-start; }
    canvas { background:#000; border-radius:14px; border:1px solid rgba(255,255,255,.12); touch-action:none; }
    .panel { min-width: 240px; flex: 1; }
    .big { font-size: 54px; font-weight: 900; margin: 6px 0; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 13px; opacity:.9; }
    details { margin-top:10px; opacity:.9; }
    summary { cursor: pointer; }
  </style>
</head>
<body>
  <main class="wrap">
    <h1>–ù–µ–π—Ä–æ—Å–µ—Ç—å: —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä—É–∫–æ–ø–∏—Å–Ω—ã—Ö —Ü–∏—Ñ—Ä</h1>
    <p class="sub">–†–∏—Å—É–π –ø–∞–ª—å—Ü–µ–º —Ü–∏—Ñ—Ä—É (0‚Äì9) ‚Üí ¬´–£–≥–∞–¥–∞—Ç—å¬ª. –ù–∞–∂–º–∏ ¬´–û–±—É—á–∏—Ç—å¬ª, —á—Ç–æ–±—ã —Å—Ç–∞–ª–æ —Ç–æ—á–Ω–µ–µ. –ú–æ–¥–µ–ª—å –º–æ–∂–Ω–æ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ –±—Ä–∞—É–∑–µ—Ä–µ.</p>

    <section class="card">
      <div class="canvasWrap">
        <div>
          <canvas id="draw" width="280" height="280"></canvas>
          <div class="row">
            <button id="btnClear" class="ghost">–°—Ç–µ—Ä–µ—Ç—å</button>
            <button id="btnGuess">ü§ñ –£–≥–∞–¥–∞—Ç—å</button>
          </div>
        </div>

        <div class="panel">
          <div>–°—Ç–∞—Ç—É—Å: <b id="status">–∑–∞–≥—Ä—É–∑–∫–∞‚Ä¶</b></div>
          <div class="big" id="pred">‚Äî</div>
          <div class="mono" id="conf">–£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: ‚Äî</div>
          <div class="mono">–¢–æ–ø-3: <span id="top3">‚Äî</span></div>

          <div class="row">
            <button id="btnTrain">üéì –û–±—É—á–∏—Ç—å (—Ç–æ—á–Ω–µ–µ)</button>
            <button id="btnSave" class="ghost" disabled>üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
            <button id="btnLoad" class="ghost">üì¶ –ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
          </div>

          <details>
            <summary>–ü–æ–¥—Å–∫–∞–∑–∫–∏</summary>
            <ul>
              <li>–†–∏—Å—É–π –±–ª–∏–∂–µ –∫ —Ü–µ–Ω—Ç—Ä—É, –æ–¥–Ω–∏–º —à—Ç—Ä–∏—Ö–æ–º, –ø–æ—Ç–æ–ª—â–µ.</li>
              <li>–ï—Å–ª–∏ –ø—É—Ç–∞–µ—Ç 1/7 –∏–ª–∏ 3/8 ‚Äî —Å–¥–µ–ª–∞–π —Ü–∏—Ñ—Ä—ã –ø–æ–Ω—è—Ç–Ω–µ–µ.</li>
              <li>¬´–°–æ—Ö—Ä–∞–Ω–∏—Ç—å¬ª –∫–ª–∞–¥—ë—Ç –º–æ–¥–µ–ª—å –≤ –ø–∞–º—è—Ç—å –±—Ä–∞—É–∑–µ—Ä–∞ –Ω–∞ iPhone (IndexedDB).</li>
            </ul>
          </details>
        </div>
      </div>
    </section>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>

  <script>
    const $ = (id) => document.getElementById(id);
    const canvas = $('draw');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });

    const btnClear = $('btnClear');
    const btnGuess = $('btnGuess');
    const btnTrain = $('btnTrain');
    const btnSave  = $('btnSave');
    const btnLoad  = $('btnLoad');

    const statusEl = $('status');
    const predEl   = $('pred');
    const confEl   = $('conf');
    const top3El   = $('top3');

    function setStatus(s){ statusEl.textContent = s; }
    function setOut(pred, conf, top3){
      predEl.textContent = pred;
      confEl.textContent = conf;
      top3El.textContent = top3;
    }

    // ---------- drawing ----------
    function clearCanvas(){
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 22;
      setOut('‚Äî','–£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: ‚Äî','‚Äî');
    }
    clearCanvas();

    let drawing = false;
    let lastX = 0, lastY = 0;

    function getPos(e){
      const r = canvas.getBoundingClientRect();
      const t = e.touches?.[0];
      const x = (t ? t.clientX : e.clientX) - r.left;
      const y = (t ? t.clientY : e.clientY) - r.top;
      return { x, y };
    }

    function startDraw(e){
      drawing = true;
      const {x,y} = getPos(e);
      lastX = x; lastY = y;
      e.preventDefault();
    }
    function moveDraw(e){
      if(!drawing) return;
      const {x,y} = getPos(e);
      ctx.beginPath();
      ctx.moveTo(lastX,lastY);
      ctx.lineTo(x,y);
      ctx.stroke();
      lastX = x; lastY = y;
      e.preventDefault();
    }
    function endDraw(){ drawing = false; }

    canvas.addEventListener('mousedown', startDraw);
    canvas.addEventListener('mousemove', moveDraw);
    window.addEventListener('mouseup', endDraw);

    canvas.addEventListener('touchstart', startDraw, { passive:false });
    canvas.addEventListener('touchmove', moveDraw, { passive:false });
    canvas.addEventListener('touchend', endDraw);

    btnClear.addEventListener('click', clearCanvas);

    // ---------- model ----------
    let model = null;

    function buildModel(){
      const m = tf.sequential();
      m.add(tf.layers.conv2d({ inputShape:[28,28,1], filters:16, kernelSize:3, activation:'relu' }));
      m.add(tf.layers.maxPooling2d({ poolSize:2 }));
      m.add(tf.layers.conv2d({ filters:32, kernelSize:3, activation:'relu' }));
      m.add(tf.layers.maxPooling2d({ poolSize:2 }));
      m.add(tf.layers.flatten());
      m.add(tf.layers.dense({ units:64, activation:'relu' }));
      m.add(tf.layers.dropout({ rate:0.2 }));
      m.add(tf.layers.dense({ units:10, activation:'softmax' }));
      m.compile({ optimizer: tf.train.adam(0.001), loss:'categoricalCrossentropy', metrics:['accuracy'] });
      return m;
    }

    // ---------- IMPORTANT: better preprocessing (crop + center) ----------
    function canvasToTensor(){
      return tf.tidy(() => {
        // grayscale 0..1 (white=1)
        const img = tf.browser.fromPixels(canvas, 1).toFloat().div(255.0).squeeze(); // [280,280]

        // ink = "—á–µ—Ä–Ω–∏–ª–∞" (1=—á–µ—Ä–Ω–∏–ª–∞, 0=—Ñ–æ–Ω)
        // —Ñ–æ–Ω —á–µ—Ä–Ω—ã–π => img ~0, –ª–∏–Ω–∏–∏ –±–µ–ª—ã–µ => img ~1, –∑–Ω–∞—á–∏—Ç —á–µ—Ä–Ω–∏–ª–∞ = img
        // –Ω–æ MNIST: —á–µ—Ä–Ω–∏–ª–∞ —è—Ä–∫–∏–µ, —Ñ–æ–Ω —Ç—ë–º–Ω—ã–π, —Ç–∞–∫ —á—Ç–æ –æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å.
        const ink = img;

        // –º–∞—Å–∫–∞ —á–µ—Ä–Ω–∏–ª
        const mask = ink.greater(0.08);
        const coords = tf.where(mask); // [N,2] (y,x)

        // –µ—Å–ª–∏ –ø—É—Å—Ç–æ
        if (coords.shape[0] === 0) {
          return tf.zeros([1,28,28,1]);
        }

        const ys = coords.slice([0,0],[coords.shape[0],1]);
        const xs = coords.slice([0,1],[coords.shape[0],1]);

        const ymin = ys.min().dataSync()[0];
        const ymax = ys.max().dataSync()[0];
        const xmin = xs.min().dataSync()[0];
        const xmax = xs.max().dataSync()[0];

        // crop + padding
        const pad = 14;
        const y0 = Math.max(0, ymin - pad);
        const x0 = Math.max(0, xmin - pad);
        const y1 = Math.min(279, ymax + pad);
        const x1 = Math.min(279, xmax + pad);

        const h = y1 - y0 + 1;
        const w = x1 - x0 + 1;

        let cropped = ink.slice([y0, x0],[h, w]); // [h,w]

        // –¥–µ–ª–∞–µ–º –∫–≤–∞–¥—Ä–∞—Ç
        const size = Math.max(h, w);
        const top = Math.floor((size - h)/2);
        const bottom = size - h - top;
        const left = Math.floor((size - w)/2);
        const right = size - w - left;

        cropped = tf.pad(cropped, [[top,bottom],[left,right]]); // [size,size]

        // resize to 28x28
        let resized = tf.image.resizeBilinear(cropped.expandDims(-1), [28,28]); // [28,28,1]

        // –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è/–∫–æ–Ω—Ç—Ä–∞—Å—Ç
        // –¥–µ–ª–∞–µ–º —á—É—Ç—å —Å–∏–ª—å–Ω–µ–µ —á–µ—Ä–Ω–∏–ª–∞
        resized = resized.clipByValue(0,1);
        resized = resized.pow(0.7); // —É—Å–∏–ª–∏–≤–∞–µ–º —è—Ä–∫–∏–µ –ø–∏–∫—Å–µ–ª–∏

        // MNIST-—Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å: –≤ MNIST —Ñ–æ–Ω —á–µ—Ä–Ω—ã–π, —á–µ—Ä–Ω–∏–ª–∞ –±–µ–ª—ã–µ -> —É –Ω–∞—Å —Ç–∞–∫ –∂–µ, –æ–∫.
        return resized.expandDims(0); // [1,28,28,1]
      });
    }

    function predict(){
      if(!model){ setStatus('–º–æ–¥–µ–ª—å –Ω–µ –≥–æ—Ç–æ–≤–∞'); return; }
      const x = canvasToTensor();
      const y = model.predict(x);
      const probs = y.dataSync();
      x.dispose(); y.dispose();

      const arr = Array.from(probs).map((p,i)=>({i,p}));
      arr.sort((a,b)=>b.p-a.p);
      const best = arr[0];
      const top3 = arr.slice(0,3).map(o => `${o.i}:${(o.p*100).toFixed(1)}%`).join('  ');

      setOut(String(best.i), `–£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: ${(best.p*100).toFixed(1)}%`, top3);
      setStatus('–ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –≥–æ—Ç–æ–≤–æ');
    }

    btnGuess.addEventListener('click', predict);

    // ---------- training data (MNIST mini) ----------
    async function loadMnistMini(){
      setStatus('–∫–∞—á–∞—é –º–∏–Ω–∏-–¥–∞—Ç–∞—Å–µ—Ç‚Ä¶');

      const IMG_URL   = 'https://storage.googleapis.com/learnjs-data/model-builder/mnist_images.png';
      const LABEL_URL = 'https://storage.googleapis.com/learnjs-data/model-builder/mnist_labels_uint8';

      const img = new Image();
      img.crossOrigin = '';
      img.src = IMG_URL;
      await new Promise((res, rej)=>{ img.onload=res; img.onerror=rej; });

      const labelBuf = await fetch(LABEL_URL).then(r => r.arrayBuffer());
      const labelData = new Uint8Array(labelBuf);

      const NUM = 2200;
      const H = 28, W = 28;

      const CAN = document.createElement('canvas');
      CAN.width = img.width;
      CAN.height = img.height;
      const c = CAN.getContext('2d', { willReadFrequently: true });
      c.drawImage(img, 0, 0);

      const isStrip = (img.width === 28); // —É —ç—Ç–æ–≥–æ —Ñ–∞–π–ª–∞ –æ–±—ã—á–Ω–æ —Ç–∞–∫
      const images = new Float32Array(NUM * H * W);

      if(isStrip){
        for(let i=0;i<NUM;i++){
          const imageData = c.getImageData(0, i*H, W, H).data;
          for(let j=0;j<H*W;j++){
            images[i*H*W + j] = imageData[j*4] / 255;
          }
        }
      } else {
        const perRow = Math.floor(img.width / W);
        for(let i=0;i<NUM;i++){
          const sx = (i % perRow) * W;
          const sy = Math.floor(i / perRow) * H;
          const imageData = c.getImageData(sx, sy, W, H).data;
          for(let j=0;j<H*W;j++){
            images[i*H*W + j] = imageData[j*4] / 255;
          }
        }
      }

      const labels = new Uint8Array(NUM * 10);
      labels.set(labelData.slice(0, NUM*10));

      const TRAIN = 2000;
      const testCount = NUM - TRAIN;

      const xTrain = tf.tensor4d(images.slice(0, TRAIN*H*W), [TRAIN, H, W, 1]);
      const yTrain = tf.tensor2d(labels.slice(0, TRAIN*10), [TRAIN, 10]);

      const xTest = tf.tensor4d(images.slice(TRAIN*H*W), [testCount, H, W, 1]);
      const yTest = tf.tensor2d(labels.slice(TRAIN*10), [testCount, 10]);

      setStatus('–¥–∞—Ç–∞—Å–µ—Ç –≥–æ—Ç–æ–≤');
      return { xTrain, yTrain, xTest, yTest };
    }

    async function train(){
      if(!model) model = buildModel();

      btnTrain.disabled = true;
      btnGuess.disabled = true;
      btnSave.disabled = true;

      let data;
      try{
        data = await loadMnistMini();
      } catch(e){
        console.error(e);
        setStatus('–Ω–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å –¥–∞—Ç–∞—Å–µ—Ç (–ø—Ä–æ–≤–µ—Ä—å –∏–Ω—Ç–µ—Ä–Ω–µ—Ç)');
        btnTrain.disabled = false;
        btnGuess.disabled = false;
        return;
      }

      setStatus('–æ–±—É—á–∞—é‚Ä¶');
      try{
        await model.fit(data.xTrain, data.yTrain, {
          epochs: 10,             // –±–æ–ª—å—à–µ —ç–ø–æ—Ö = —Ç–æ—á–Ω–µ–µ
          batchSize: 64,
          validationData: [data.xTest, data.yTest],
          callbacks: {
            onEpochEnd: (ep, logs) => {
              const acc = logs?.acc ?? logs?.accuracy ?? 0;
              const val = logs?.val_acc ?? logs?.val_accuracy ?? 0;
              setStatus(`—ç–ø–æ—Ö–∞ ${ep+1}/10 ‚Äî acc ${(acc*100).toFixed(1)}% ‚Äî val ${(val*100).toFixed(1)}%`);
            }
          }
        });
        setStatus('–æ–±—É—á–µ–Ω–∏–µ –≥–æ—Ç–æ–≤–æ ‚úÖ');
        btnSave.disabled = false;
      } finally {
        data.xTrain.dispose(); data.yTrain.dispose();
        data.xTest.dispose();  data.yTest.dispose();
        btnTrain.disabled = false;
        btnGuess.disabled = false;
      }
    }

    btnTrain.addEventListener('click', train);

    // ---------- save/load ----------
    btnSave.addEventListener('click', async () => {
      if(!model) return;
      setStatus('—Å–æ—Ö—Ä–∞–Ω—è—é –º–æ–¥–µ–ª—å‚Ä¶');
      await model.save('indexeddb://digit-draw-model');
      setStatus('—Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ ‚úÖ');
    });

    btnLoad.addEventListener('click', async () => {
      setStatus('–ø—ã—Ç–∞—é—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –º–æ–¥–µ–ª—å‚Ä¶');
      try{
        model = await tf.loadLayersModel('indexeddb://digit-draw-model');
        setStatus('–º–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞ ‚úÖ');
        btnSave.disabled = false;
      } catch(e){
        setStatus('—Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–π –º–æ–¥–µ–ª–∏ –Ω–µ—Ç (–Ω–∞–∂–º–∏ ¬´–û–±—É—á–∏—Ç—å¬ª, –ø–æ—Ç–æ–º ¬´–°–æ—Ö—Ä–∞–Ω–∏—Ç—å¬ª)');
      }
    });

    // init
    (async () => {
      model = buildModel(); // –≥–æ—Ç–æ–≤–∞, –Ω–æ –Ω–µ –æ–±—É—á–µ–Ω–∞ –ø–æ–∫–∞
      setStatus('–≥–æ—Ç–æ–≤–æ: —Ä–∏—Å—É–π –∏ –∂–º–∏ ¬´–£–≥–∞–¥–∞—Ç—å¬ª (–¥–ª—è —Ç–æ—á–Ω–æ—Å—Ç–∏ ‚Äî ¬´–û–±—É—á–∏—Ç—å¬ª)');
      setOut('‚Äî','–£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: ‚Äî','‚Äî');
    })();
  </script>
</body>
</html>
