<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ü–∏—Ñ—Ä (—Ä–∏—Å—É–π ‚Üí —É–≥–∞–¥—ã–≤–∞—é)</title>
  <style>
    :root { font-family: -apple-system, system-ui, Arial; }
    body { margin:0; background:#0b0d12; color:#e9eefc; }
    .wrap { max-width: 920px; margin: 0 auto; padding: 18px; }
    h1 { margin: 10px 0 6px; font-size: 24px; }
    .sub { margin: 0 0 12px; opacity:.8; line-height:1.35; }
    .card { background:#111626; border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:14px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:10px 0; }
    button { border:0; border-radius:12px; padding:12px 14px; font-weight:700; background:#2a6bff; color:#fff; }
    button.ghost { background:transparent; border:1px solid rgba(255,255,255,.18); }
    button:disabled { opacity:.4; }
    .canvasWrap { display:flex; gap:12px; flex-wrap:wrap; align-items:flex-start; }
    canvas { background:#000; border-radius:14px; border:1px solid rgba(255,255,255,.12); touch-action:none; }
    .panel { min-width: 220px; flex: 1; }
    .big { font-size: 44px; font-weight: 900; margin: 6px 0; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 13px; opacity:.9; }
    .bar { height: 10px; border-radius: 10px; background: rgba(255,255,255,.12); overflow:hidden; }
    .bar > div { height:100%; width:0%; background:#2a6bff; }
    details { margin-top:10px; opacity:.9; }
  </style>
</head>
<body>
  <main class="wrap">
    <h1>–ù–µ–π—Ä–æ—Å–µ—Ç—å: —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä—É–∫–æ–ø–∏—Å–Ω—ã—Ö —Ü–∏—Ñ—Ä</h1>
    <p class="sub">–ù–∞—Ä–∏—Å—É–π –ø–∞–ª—å—Ü–µ–º —Ü–∏—Ñ—Ä—É (0‚Äì9) –Ω–∞ —á—ë—Ä–Ω–æ–º –ø–æ–ª–µ ‚Üí –Ω–∞–∂–º–∏ ¬´–£–≥–∞–¥–∞—Ç—å¬ª. –ú–æ–∂–Ω–æ –æ–±—É—á–∏—Ç—å –º–æ–¥–µ–ª—å (MNIST –º–∏–Ω–∏-–¥–∞—Ç–∞—Å–µ—Ç).</p>

    <section class="card">
      <div class="canvasWrap">
        <div>
          <canvas id="draw" width="280" height="280"></canvas>
          <div class="row">
            <button id="btnClear" class="ghost">–°—Ç–µ—Ä–µ—Ç—å</button>
            <button id="btnGuess" disabled>ü§ñ –£–≥–∞–¥–∞—Ç—å</button>
          </div>
        </div>

        <div class="panel">
          <div>–°—Ç–∞—Ç—É—Å: <b id="status">–∑–∞–≥—Ä—É–∑–∫–∞‚Ä¶</b></div>
          <div class="big" id="pred">‚Äî</div>
          <div class="mono" id="conf">–£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: ‚Äî</div>
          <div class="row">
            <button id="btnTrain">üéì –û–±—É—á–∏—Ç—å (–±—ã—Å—Ç—Ä–æ)</button>
            <button id="btnSave" class="ghost" disabled>üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
            <button id="btnLoad" class="ghost">üì¶ –ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
          </div>

          <div class="mono">–¢–æ–ø-3:</div>
          <div id="top3" class="mono">‚Äî</div>

          <details>
            <summary>–ü–æ–¥—Å–∫–∞–∑–∫–∏</summary>
            <ul>
              <li>–†–∏—Å—É–π –ø–æ—Ç–æ–ª—â–µ –∏ –ø–æ —Ü–µ–Ω—Ç—Ä—É.</li>
              <li>–ü–æ—Å–ª–µ –æ–±—É—á–µ–Ω–∏—è —Ç–æ—á–Ω–æ—Å—Ç—å —Å–∏–ª—å–Ω–æ —Ä–∞—Å—Ç—ë—Ç.</li>
              <li>–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ö—Ä–∞–Ω–∏—Ç –º–æ–¥–µ–ª—å –≤ –±—Ä–∞—É–∑–µ—Ä–µ (–Ω–∞ iPhone —Ç–æ–∂–µ).</li>
            </ul>
          </details>
        </div>
      </div>
    </section>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>

  <script>
    const $ = (id) => document.getElementById(id);
    const canvas = $('draw');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });

    const btnClear = $('btnClear');
    const btnGuess = $('btnGuess');
    const btnTrain = $('btnTrain');
    const btnSave  = $('btnSave');
    const btnLoad  = $('btnLoad');

    const statusEl = $('status');
    const predEl   = $('pred');
    const confEl   = $('conf');
    const top3El   = $('top3');

    function setStatus(s){ statusEl.textContent = s; }
    function setPred(p, conf, top3){
      predEl.textContent = p;
      confEl.textContent = conf;
      top3El.textContent = top3;
    }

    // ---------- drawing ----------
    function clearCanvas(){
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 22;
      setPred('‚Äî','–£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: ‚Äî','‚Äî');
      btnGuess.disabled = false;
    }
    clearCanvas();

    let drawing = false;
    let lastX = 0, lastY = 0;

    function getPos(e){
      const r = canvas.getBoundingClientRect();
      const t = e.touches?.[0];
      const x = (t ? t.clientX : e.clientX) - r.left;
      const y = (t ? t.clientY : e.clientY) - r.top;
      return { x, y };
    }

    function startDraw(e){
      drawing = true;
      const {x,y} = getPos(e);
      lastX = x; lastY = y;
      e.preventDefault();
    }
    function moveDraw(e){
      if(!drawing) return;
      const {x,y} = getPos(e);
      ctx.beginPath();
      ctx.moveTo(lastX,lastY);
      ctx.lineTo(x,y);
      ctx.stroke();
      lastX = x; lastY = y;
      e.preventDefault();
    }
    function endDraw(){ drawing = false; }

    canvas.addEventListener('mousedown', startDraw);
    canvas.addEventListener('mousemove', moveDraw);
    window.addEventListener('mouseup', endDraw);

    canvas.addEventListener('touchstart', startDraw, { passive:false });
    canvas.addEventListener('touchmove', moveDraw, { passive:false });
    canvas.addEventListener('touchend', endDraw);

    btnClear.addEventListener('click', clearCanvas);

    // ---------- model ----------
    let model = null;

    function buildModel(){
      // –ü—Ä–æ—Å—Ç–∞—è CNN –¥–ª—è 28x28x1
      const m = tf.sequential();
      m.add(tf.layers.conv2d({ inputShape:[28,28,1], filters:16, kernelSize:3, activation:'relu' }));
      m.add(tf.layers.maxPooling2d({ poolSize:2 }));
      m.add(tf.layers.conv2d({ filters:32, kernelSize:3, activation:'relu' }));
      m.add(tf.layers.maxPooling2d({ poolSize:2 }));
      m.add(tf.layers.flatten());
      m.add(tf.layers.dense({ units:64, activation:'relu' }));
      m.add(tf.layers.dropout({ rate:0.2 }));
      m.add(tf.layers.dense({ units:10, activation:'softmax' }));
      m.compile({ optimizer: tf.train.adam(0.001), loss:'categoricalCrossentropy', metrics:['accuracy'] });
      return m;
    }

    // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å canvas -> 28x28 —Ç–µ–Ω–∑–æ—Ä
    function canvasToTensor(){
      return tf.tidy(() => {
        const img = tf.browser.fromPixels(canvas, 1);     // [280,280,1]
        // —É–º–µ–Ω—å—à–∏—Ç—å –¥–æ 28x28
        const small = tf.image.resizeBilinear(img, [28,28]);
        // –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è 0..1
        const norm = small.toFloat().div(255.0);
        // –∏–Ω–≤–µ—Ä—Å–∏—è (—Ñ–æ–Ω —á–µ—Ä–Ω—ã–π, –ª–∏–Ω–∏–∏ –±–µ–ª—ã–µ ‚Äî –Ω–æ—Ä–º, –Ω–æ MNIST –æ–±—ã—á–Ω–æ –±–µ–ª—ã–π —Ñ–æ–Ω/—á–µ—Ä–Ω—ã–µ —Ü–∏—Ñ—Ä—ã; –∏–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –ø–æ–¥ MNIST)
        const inv = tf.sub(1.0, norm);
        // –¥–æ–±–∞–≤–∏—Ç—å batch
        return inv.expandDims(0); // [1,28,28,1]
      });
    }

    function predict(){
      if(!model){ setStatus('–º–æ–¥–µ–ª—å –Ω–µ –≥–æ—Ç–æ–≤–∞'); return; }
      const x = canvasToTensor();
      const y = model.predict(x);
      const probs = y.dataSync(); // 10 —á–∏—Å–µ–ª
      x.dispose(); y.dispose();

      // top-3
      const arr = Array.from(probs).map((p,i)=>({i,p}));
      arr.sort((a,b)=>b.p-a.p);
      const best = arr[0];
      const top3 = arr.slice(0,3).map(o => `${o.i}:${(o.p*100).toFixed(1)}%`).join('  ');
      setPred(String(best.i), `–£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: ${(best.p*100).toFixed(1)}%`, top3);
      setStatus('–ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –≥–æ—Ç–æ–≤–æ');
    }

    btnGuess.addEventListener('click', predict);

    // ---------- training data (MNIST mini) ----------
    // –ë–µ—Ä—ë–º –º–∞–ª–µ–Ω—å–∫–∏–π –Ω–∞–±–æ—Ä MNIST –∏–∑ tfjs-examples (CDN). –≠—Ç–æ —Å–∞–º—ã–π –±—ã—Å—Ç—Ä—ã–π —Å–ø–æ—Å–æ–± –±–µ–∑ —Å–µ—Ä–≤–µ—Ä–∞.
    async function loadMnistMini(){
      setStatus('–∫–∞—á–∞—é –º–∏–Ω–∏-–¥–∞—Ç–∞—Å–µ—Ç‚Ä¶');
      // –≠—Ç–∏ —Ñ–∞–π–ª—ã –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –≤ –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã—Ö –ø—Ä–∏–º–µ—Ä–∞—Ö tfjs (mnist)
      // 2 —Å–ø—Ä–∞–π—Ç–∞: –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏ –º–µ—Ç–∫–∏. –ú–∏–Ω–∏-–≤–µ—Ä—Å–∏—è: 2000 train + 200 test.
      const IMG_URL = 'https://storage.googleapis.com/learnjs-data/model-builder/mnist_images.png';
      const LABEL_URL = 'https://storage.googleapis.com/learnjs-data/model-builder/mnist_labels_uint8';

      const img = new Image();
      img.crossOrigin = '';
      img.src = IMG_URL;
      await new Promise((res, rej)=>{ img.onload=res; img.onerror=rej; });

      const { data: labelData } = await tf.util.fetch(LABEL_URL, { method:'GET' }).then(r=>r.arrayBuffer()).then(buf=>({data: new Uint8Array(buf)}));

      // –†–∞–∑–±–∏—Ä–∞–µ–º —Å–ø—Ä–∞–π—Ç: 28x28, 65000 –ø—Ä–∏–º–µ—Ä–æ–≤ –≤ –æ—Ä–∏–≥–∏–Ω–∞–ª–µ.
      // –ú—ã –≤–æ–∑—å–º—ë–º –ø–µ—Ä–≤—ã–µ 2200 (2000 train + 200 test) —á—Ç–æ–±—ã –±—ã—Å—Ç—Ä–æ.
      const NUM = 2200;
      const H = 28, W = 28;
      const CAN = document.createElement('canvas');
      CAN.width = img.width;
      CAN.height = img.height;
      const c = CAN.getContext('2d', { willReadFrequently: true });
      c.drawImage(img, 0, 0);

      // –í —Å–ø—Ä–∞–π—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–¥—É—Ç –≤ —Å–µ—Ç–∫–µ –ø–æ 5000 –≤ —Ä—è–¥ –≤ –ø—Ä–∏–º–µ—Ä–∞—Ö tfjs? ‚Äî —Ç—É—Ç –ø—Ä–æ—â–µ:
      // –í –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ–º —Ñ–∞–π–ª–µ model-builder/mnist_images.png —ç—Ç–æ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è "–ª–µ–Ω—Ç–∞": —à–∏—Ä–∏–Ω–∞ 28, –≤—ã—Å–æ—Ç–∞ 28*65000.
      // –ü–æ—ç—Ç–æ–º—É —á–∏—Ç–∞–µ–º –ø–æ–¥—Ä—è–¥ –±–ª–æ–∫–∞–º–∏ 28x28 –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏.
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º: –µ—Å–ª–∏ —à–∏—Ä–∏–Ω–∞ != 28, –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥—Ä—É–≥–æ–π —Å–ø–æ—Å–æ–± (–Ω–∞ –≤—Å—è–∫–∏–π).
      const isStrip = (img.width === 28);

      const images = new Float32Array(NUM * H * W);

      if(isStrip){
        // strip: [28, 28*65000]
        for(let i=0;i<NUM;i++){
          const imageData = c.getImageData(0, i*H, W, H).data;
          for(let j=0;j<H*W;j++){
            // –±–µ—Ä—ë–º R –∫–∞–Ω–∞–ª
            images[i*H*W + j] = imageData[j*4] / 255;
          }
        }
      } else {
        // fallback: –µ—Å–ª–∏ —Å–ø—Ä–∞–π—Ç —Å–µ—Ç–∫–æ–π
        const perRow = Math.floor(img.width / W);
        for(let i=0;i<NUM;i++){
          const sx = (i % perRow) * W;
          const sy = Math.floor(i / perRow) * H;
          const imageData = c.getImageData(sx, sy, W, H).data;
          for(let j=0;j<H*W;j++){
            images[i*H*W + j] = imageData[j*4] / 255;
          }
        }
      }

      // labels: one-hot –ø–æ 10, –∑–Ω–∞—á–∏—Ç –¥–ª–∏–Ω–∞ labelData –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å >= NUM*10
      const labels = new Uint8Array(NUM * 10);
      labels.set(labelData.slice(0, NUM*10));

      // train/test split
      const TRAIN = 2000;
      const testCount = NUM - TRAIN;

      const xTrain = tf.tensor4d(images.slice(0, TRAIN*H*W), [TRAIN, H, W, 1]);
      const yTrain = tf.tensor2d(labels.slice(0, TRAIN*10), [TRAIN, 10]);

      const xTest = tf.tensor4d(images.slice(TRAIN*H*W), [testCount, H, W, 1]);
      const yTest = tf.tensor2d(labels.slice(TRAIN*10), [testCount, 10]);

      setStatus('–¥–∞—Ç–∞—Å–µ—Ç –≥–æ—Ç–æ–≤');
      return { xTrain, yTrain, xTest, yTest };
    }

    async function train(){
      if(!model) model = buildModel();

      setStatus('–≥–æ—Ç–æ–≤–ª—é –¥–∞–Ω–Ω—ã–µ‚Ä¶');
      btnTrain.disabled = true;
      btnGuess.disabled = true;

      let data;
      try{
        data = await loadMnistMini();
      } catch(e){
        console.error(e);
        setStatus('–Ω–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å –¥–∞—Ç–∞—Å–µ—Ç (–ø—Ä–æ–≤–µ—Ä—å –∏–Ω—Ç–µ—Ä–Ω–µ—Ç)');
        btnTrain.disabled = false;
        btnGuess.disabled = false;
        return;
      }

      setStatus('–æ–±—É—á–∞—é‚Ä¶ (–±—ã—Å—Ç—Ä–æ)');
      try{
        await model.fit(data.xTrain, data.yTrain, {
          epochs: 3,
          batchSize: 64,
          validationData: [data.xTest, data.yTest],
          callbacks: {
            onEpochEnd: (ep, logs) => {
              const acc = logs?.acc ?? logs?.accuracy ?? 0;
              const val = logs?.val_acc ?? logs?.val_accuracy ?? 0;
              setStatus(`—ç–ø–æ—Ö–∞ ${ep+1}/3 ‚Äî acc ${(acc*100).toFixed(1)}% ‚Äî val ${(val*100).toFixed(1)}%`);
            }
          }
        });
        setStatus('–æ–±—É—á–µ–Ω–∏–µ –≥–æ—Ç–æ–≤–æ ‚úÖ —Ä–∏—Å—É–π –∏ —É–≥–∞–¥—ã–≤–∞–π');
        btnSave.disabled = false;
      } finally {
        data.xTrain.dispose(); data.yTrain.dispose();
        data.xTest.dispose();  data.yTest.dispose();
        btnGuess.disabled = false;
        btnTrain.disabled = false;
      }
    }

    btnTrain.addEventListener('click', train);

    // ---------- save/load ----------
    btnSave.addEventListener('click', async () => {
      if(!model) return;
      setStatus('—Å–æ—Ö—Ä–∞–Ω—è—é –º–æ–¥–µ–ª—å‚Ä¶');
      await model.save('indexeddb://digit-draw-model');
      setStatus('—Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ ‚úÖ');
    });

    btnLoad.addEventListener('click', async () => {
      setStatus('–ø—ã—Ç–∞—é—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –º–æ–¥–µ–ª—å‚Ä¶');
      try{
        model = await tf.loadLayersModel('indexeddb://digit-draw-model');
        setStatus('–º–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞ ‚úÖ');
        btnGuess.disabled = false;
        btnSave.disabled = false;
      } catch(e){
        setStatus('—Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–π –º–æ–¥–µ–ª–∏ –Ω–µ—Ç (–Ω–∞–∂–º–∏ ¬´–û–±—É—á–∏—Ç—å¬ª, –ø–æ—Ç–æ–º ¬´–°–æ—Ö—Ä–∞–Ω–∏—Ç—å¬ª)');
      }
    });

    // init
    (async () => {
      model = buildModel(); // —Å—Ä–∞–∑—É –≥–æ—Ç–æ–≤–∞ (–Ω–æ –Ω–µ –æ–±—É—á–µ–Ω–∞)
      setStatus('–≥–æ—Ç–æ–≤–æ: –Ω–∞—Ä–∏—Å—É–π —Ü–∏—Ñ—Ä—É –∏–ª–∏ –Ω–∞–∂–º–∏ ¬´–û–±—É—á–∏—Ç—å¬ª');
      btnGuess.disabled = false;
    })();
  </script>
</body>
</html>
