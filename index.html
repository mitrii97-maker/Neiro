<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>–ö—Ä–∞—Å–Ω—ã–µ vs –°–∏–Ω–∏–µ: –æ–±—É—á–µ–Ω–∏–µ –∞—Ç–∞–∫–∏ –∏ –∑–∞—â–∏—Ç—ã</title>
  <style>
    :root { font-family: -apple-system, system-ui, Arial; }
    body { margin:0; background:#0b0d12; color:#e9eefc; }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 16px; }
    h1 { margin: 8px 0 6px; font-size: 20px; }
    .sub { margin: 0 0 12px; opacity:.85; line-height:1.35; }
    .card { background:#111626; border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:14px; }

    .grid { display:grid; grid-template-columns: 1.2fr 1fr; gap:12px; }
    @media (max-width: 920px){ .grid { grid-template-columns: 1fr; } }

    canvas { width:100%; height:auto; background:#0a0f1c; border-radius:14px; border:1px solid rgba(255,255,255,.12); }

    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:10px 0; }
    button {
      border:0; border-radius:12px; padding:12px 14px; font-weight:800;
      background:#2a6bff; color:#fff;
    }
    button.ghost { background:transparent; border:1px solid rgba(255,255,255,.18); }
    button:disabled { opacity:.45; }

    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 13px; opacity:.92; }
    .pill { display:inline-block; padding:6px 10px; border:1px solid rgba(255,255,255,.15); border-radius:999px; }

    .bar { height: 10px; background: rgba(255,255,255,.12); border-radius:999px; overflow:hidden; }
    .bar > div { height:100%; width:0%; background:#2a6bff; }

    .barRed > div { background:#ff3b30; }
    .barBlue > div { background:#2a6bff; }

    .legend { display:flex; gap:10px; flex-wrap:wrap; }
    .sw { display:inline-flex; gap:6px; align-items:center; }
    .dot { width:12px; height:12px; border-radius:3px; display:inline-block; border:1px solid rgba(255,255,255,.18); }
  </style>
</head>
<body>
  <main class="wrap">
    <h1>–ö—Ä–∞—Å–Ω—ã–µ vs –°–∏–Ω–∏–µ ‚Äî ‚Äú–æ–±—É—á–µ–Ω–∏–µ‚Äù –≤ –±–æ—é</h1>
    <p class="sub">
      –ö—Ä–∞—Å–Ω—ã–µ –≤—ã–±–∏—Ä–∞—é—Ç –≤—Ö–æ–¥ –∏ —É—á–∞—Ç—Å—è, –∫–∞–∫–æ–π –≤—Ö–æ–¥ –ø—Ä–∏–Ω–æ—Å–∏—Ç –ø—Ä–æ—Ä—ã–≤. –°–∏–Ω–∏–µ —É—á–∞—Ç—Å—è, –∫—É–¥–∞ —á–∞—â–µ –∞—Ç–∞–∫—É—é—Ç, –∏ —Å—Ç–∞–≤—è—Ç –±–∞—Ä—Ä–∏–∫–∞–¥—ã.
      –≠—Ç–æ –Ω–µ ‚Äú–∑–∞—Ä–∞–Ω–µ–µ –Ω–∞–ø–∏—Å–∞–Ω–Ω—ã–π –ø—É—Ç—å‚Äù: —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –º–µ–Ω—è—é—Ç—Å—è –≤–æ –≤—Ä–µ–º–µ–Ω–∏.
    </p>

    <section class="card">
      <div class="grid">
        <div>
          <canvas id="cv" width="900" height="900"></canvas>
          <div class="row">
            <button id="btnStart">‚ñ∂ –°—Ç–∞—Ä—Ç</button>
            <button id="btnReset" class="ghost">üîÑ –°–±—Ä–æ—Å</button>
            <button id="btnFast" class="ghost">‚ö° –ë—ã—Å—Ç—Ä–µ–µ</button>
            <button id="btnSlow" class="ghost">üê¢ –ú–µ–¥–ª–µ–Ω–Ω–µ–µ</button>
          </div>
          <div class="legend mono">
            <span class="sw"><span class="dot" style="background:#2b2f3f"></span> —Å—Ç–µ–Ω—ã</span>
            <span class="sw"><span class="dot" style="background:#2a6bff"></span> —Å–∏–Ω–∏–µ (–∑–∞—â–∏—Ç–∞)</span>
            <span class="sw"><span class="dot" style="background:#ff3b30"></span> –∫—Ä–∞—Å–Ω—ã–µ (–∞—Ç–∞–∫–∞)</span>
            <span class="sw"><span class="dot" style="background:#ffd60a"></span> –≤—Ö–æ–¥—ã</span>
            <span class="sw"><span class="dot" style="background:#7c3aed"></span> —è–¥—Ä–æ –±–∞–∑—ã</span>
            <span class="sw"><span class="dot" style="background:#a3a3a3"></span> –±–∞—Ä—Ä–∏–∫–∞–¥–∞</span>
          </div>
        </div>

        <div>
          <div class="mono">–£–º –∫—Ä–∞—Å–Ω—ã—Ö (–ø—Ä–æ—Ä—ã–≤—ã): <b id="rPct">0%</b></div>
          <div class="bar barRed"><div id="rBar"></div></div>

          <div style="height:10px"></div>

          <div class="mono">–£–º —Å–∏–Ω–∏—Ö (–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞): <b id="bPct">0%</b></div>
          <div class="bar barBlue"><div id="bBar"></div></div>

          <div class="row mono">
            <span class="pill">–¢–∏–∫: <b id="tick">0</b></span>
            <span class="pill">–ö—Ä–∞—Å–Ω—ã—Ö: <b id="rN">0</b></span>
            <span class="pill">–°–∏–Ω–∏—Ö: <b id="bN">0</b></span>
            <span class="pill">–ë–∞—Ä—Ä–∏–∫–∞–¥: <b id="barrN">0</b></span>
          </div>

          <div class="row mono">
            <span class="pill">–ê—Ç–∞–∫–∏ (–æ–∫–Ω–æ): <b id="attW">0</b></span>
            <span class="pill">–ü—Ä–æ—Ä—ã–≤—ã (–æ–∫–Ω–æ): <b id="succW">0</b></span>
            <span class="pill">–ë–ª–æ–∫–∏ (–æ–∫–Ω–æ): <b id="blockW">0</b></span>
          </div>

          <div class="mono" style="opacity:.85; line-height:1.35;">
            <b>–ß—Ç–æ —Ç—É—Ç ‚Äú—É—á–∏—Ç—Å—è‚Äù:</b><br>
            ‚Ä¢ –ö—Ä–∞—Å–Ω—ã–µ –≤—ã–±–∏—Ä–∞—é—Ç –≤—Ö–æ–¥ –ø–æ ‚Äú–≤–µ—Å—É‚Äù (softmax) –∏ –æ–±–Ω–æ–≤–ª—è—é—Ç –≤–µ—Å–∞ –ø–æ —É—Å–ø–µ—Ö–∞–º/–ø—Ä–æ–≤–∞–ª–∞–º.<br>
            ‚Ä¢ –°–∏–Ω–∏–µ –ø–µ—Ä–µ—Ä–∞—Å–ø—Ä–µ–¥–µ–ª—è—é—Ç –±–∞—Ä—Ä–∏–∫–∞–¥—ã –ø–æ ‚Äú–¥–∞–≤–ª–µ–Ω–∏—é –∞—Ç–∞–∫‚Äù –Ω–∞ –≤—Ö–æ–¥—ã.<br><br>
            –•–æ—á–µ—à—å –µ—â—ë –∫—Ä—É—á–µ ‚Äî –¥–æ–±–∞–≤–∏–º: ‚Äú—É–º–Ω—ã–µ‚Äù –ø–∞—Ç—Ä—É–ª–∏ —Å–∏–Ω–∏—Ö, —Ä–∞–∑—Ä—É—à–µ–Ω–∏–µ –±–∞—Ä—Ä–∏–∫–∞–¥, —Ä–∞–∑–Ω—ã–µ –∫–ª–∞—Å—Å—ã –∫—Ä–∞—Å–Ω—ã—Ö.
          </div>
        </div>
      </div>
    </section>
  </main>

<script>
(() => {
  // ---------- world ----------
  const W = 33, H = 33;
  const WALL = 1, EMPTY = 0;

  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');

  const btnStart = document.getElementById('btnStart');
  const btnReset = document.getElementById('btnReset');
  const btnFast = document.getElementById('btnFast');
  const btnSlow = document.getElementById('btnSlow');

  const elTick = document.getElementById('tick');
  const elRN = document.getElementById('rN');
  const elBN = document.getElementById('bN');
  const elBarrN = document.getElementById('barrN');

  const elAttW = document.getElementById('attW');
  const elSuccW = document.getElementById('succW');
  const elBlockW = document.getElementById('blockW');

  const rBar = document.getElementById('rBar');
  const bBar = document.getElementById('bBar');
  const rPct = document.getElementById('rPct');
  const bPct = document.getElementById('bPct');

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const randInt = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;

  // simulation speed
  let stepsPerFrame = 2;
  let playing = false;

  // grid + base layout
  let grid = [];
  const base = {
    x0: 11, y0: 11, x1: 21, y1: 21, // square base walls boundary
  };
  const core = { x: 16, y: 16 };

  // entrances (4)
  // each entrance is a gap in base wall and a tunnel to outside
  const entrances = [
    { name:'N', ex:16, ey:11, tx:16, ty:2 },  // opening at top wall, tunnel goes upward
    { name:'E', ex:21, ey:16, tx:30, ty:16 }, // right
    { name:'S', ex:16, ey:21, tx:16, ty:30 }, // down
    { name:'W', ex:11, ey:16, tx:2,  ty:16 }, // left
  ];

  // barricades: placed on entrance tile (ex,ey) to block
  // each barricade has hp and ttl; reds can "damage" it by pushing
  let barricades = new Map(); // key "x,y" -> {hp, ttl}

  function key(x,y){ return x + ',' + y; }

  // agents
  let reds = [];   // {x,y,targetEnt, path, stuck, life}
  let blues = [];  // {x,y, role}
  const BLUE_COUNT = 6;

  // learning state
  // red entrance preferences (policy) updated by reward
  let pref = [0,0,0,0]; // logits
  let temperature = 0.9;
  let lrRed = 0.12;

  // blue pressure estimates for entrances (EMA of attacks)
  let pressure = [0,0,0,0];
  let lrBlue = 0.08;

  // windows for progress metrics
  const WINDOW = 160;
  let recentAttacks = [];
  let recentSuccess = [];
  let recentBlocks = [];

  let tick = 0;

  function pushWindow(arr, v){
    arr.push(v);
    if(arr.length > WINDOW) arr.shift();
  }
  function sum(arr){ return arr.reduce((a,b)=>a+b,0); }

  // ---------- build map ----------
  function makeEmpty(){
    grid = Array.from({length:H},()=>Array(W).fill(EMPTY));
    barricades.clear();
  }

  function addWalls(){
    // border walls
    for(let x=0;x<W;x++){ grid[0][x]=WALL; grid[H-1][x]=WALL; }
    for(let y=0;y<H;y++){ grid[y][0]=WALL; grid[y][W-1]=WALL; }

    // base walls (a hollow square)
    for(let x=base.x0; x<=base.x1; x++){
      grid[base.y0][x]=WALL;
      grid[base.y1][x]=WALL;
    }
    for(let y=base.y0; y<=base.y1; y++){
      grid[y][base.x0]=WALL;
      grid[y][base.x1]=WALL;
    }

    // carve entrances (gaps)
    for(const e of entrances){
      grid[e.ey][e.ex] = EMPTY;
    }

    // build tunnels from each entrance to outside
    // tunnel is a 1-cell wide corridor
    for(const e of entrances){
      const dx = Math.sign(e.tx - e.ex);
      const dy = Math.sign(e.ty - e.ey);
      let x = e.ex, y = e.ey;
      while(x !== e.tx || y !== e.ty){
        x += dx; y += dy;
        if(x<=0||x>=W-1||y<=0||y>=H-1) break;
        grid[y][x] = EMPTY;
        // add tunnel walls around (for look): optional
      }
    }

    // random interior obstacles inside base (but keep passable to core)
    // make small blocks, not on core
    const obstacles = 16;
    for(let i=0;i<obstacles;i++){
      const x = randInt(base.x0+1, base.x1-1);
      const y = randInt(base.y0+1, base.y1-1);
      if(Math.abs(x-core.x)+Math.abs(y-core.y) <= 1) continue;
      grid[y][x] = WALL;
    }

    // ensure core is empty
    grid[core.y][core.x] = EMPTY;
  }

  function resetAgents(){
    reds = [];
    blues = [];
    // place blues inside base
    for(let i=0;i<BLUE_COUNT;i++){
      blues.push({
        x: randInt(base.x0+2, base.x1-2),
        y: randInt(base.y0+2, base.y1-2),
        role: 'def'
      });
    }
  }

  function resetLearning(){
    pref = [0,0,0,0];
    pressure = [0,0,0,0];
    recentAttacks = [];
    recentSuccess = [];
    recentBlocks = [];
    tick = 0;
  }

  function resetAll(){
    playing = false;
    btnStart.textContent = '‚ñ∂ –°—Ç–∞—Ä—Ç';
    makeEmpty();
    addWalls();
    resetAgents();
    resetLearning();
    updateUI();
    draw();
  }

  // ---------- pathfinding (A*) ----------
  function neighbors(x,y){
    return [
      {x:x+1,y}, {x:x-1,y}, {x,y:y+1}, {x,y:y-1},
    ];
  }
  function isBlocked(x,y){
    if(x<0||x>=W||y<0||y>=H) return true;
    if(grid[y][x]===WALL) return true;
    // barricade blocks on its tile
    if(barricades.has(key(x,y))) return true;
    return false;
  }

  function astar(sx,sy, gx,gy, maxIter=2500){
    const startK = key(sx,sy);
    const goalK = key(gx,gy);
    const open = new Map(); // k -> f
    const gScore = new Map();
    const came = new Map();

    function h(x,y){ return Math.abs(x-gx)+Math.abs(y-gy); }

    open.set(startK, h(sx,sy));
    gScore.set(startK, 0);

    let iter=0;
    while(open.size && iter++ < maxIter){
      // pick min f
      let curK=null, curF=Infinity;
      for(const [k,f] of open){
        if(f<curF){ curF=f; curK=k; }
      }
      if(curK===goalK){
        // reconstruct
        const path = [];
        let k = curK;
        while(k!==startK){
          const [x,y] = k.split(',').map(Number);
          path.push({x,y});
          k = came.get(k);
          if(!k) break;
        }
        path.reverse();
        return path;
      }
      open.delete(curK);
      const [cx,cy] = curK.split(',').map(Number);
      const cg = gScore.get(curK) ?? Infinity;

      for(const nb of neighbors(cx,cy)){
        if(isBlocked(nb.x, nb.y)) continue;
        const nk = key(nb.x, nb.y);
        const ng = cg + 1;
        const old = gScore.get(nk);
        if(old===undefined || ng < old){
          came.set(nk, curK);
          gScore.set(nk, ng);
          open.set(nk, ng + h(nb.x, nb.y));
        }
      }
    }
    return null;
  }

  // ---------- red policy ----------
  function softmaxPick(logits){
    const t = temperature;
    const exps = logits.map(v => Math.exp(v / t));
    const s = exps.reduce((a,b)=>a+b,0);
    let r = Math.random()*s;
    for(let i=0;i<exps.length;i++){
      r -= exps[i];
      if(r<=0) return i;
    }
    return exps.length-1;
  }

  function spawnRed(){
    const ent = softmaxPick(pref);

    // spawn near tunnel outer end
    const e = entrances[ent];
    // spawn around tunnel end with small randomness
    let sx = e.tx, sy = e.ty;
    sx = clamp(sx + randInt(-1,1), 1, W-2);
    sy = clamp(sy + randInt(-1,1), 1, H-2);
    // ensure not blocked
    if(grid[sy][sx]===WALL) return;

    // attack begins: count pressure
    pressure[ent] = (1-lrBlue)*pressure[ent] + lrBlue*1;

    const p = astar(sx,sy, core.x, core.y);
    reds.push({
      x:sx, y:sy,
      targetEnt: ent,
      path: p ?? [],
      stuck: 0,
      life: randInt(220, 320), // time to try before dying
    });

    pushWindow(recentAttacks, 1);
    pushWindow(recentSuccess, 0);
    pushWindow(recentBlocks, 0);
  }

  // ---------- blue defense ----------
  // Blue place limited barricades at entrances with highest pressure
  const MAX_BARRICADES = 3;
  function blueDefend(){
    // decay pressure slowly
    for(let i=0;i<pressure.length;i++){
      pressure[i] *= 0.995;
    }

    // choose entrances to barricade
    const order = [0,1,2,3].sort((a,b)=>pressure[b]-pressure[a]);

    // remove expired barricades
    for(const [k,v] of barricades){
      v.ttl -= 1;
      if(v.ttl <= 0) barricades.delete(k);
    }

    // ensure barricades on top entrances
    let placed = 0;
    for(const idx of order){
      if(placed >= MAX_BARRICADES) break;
      const e = entrances[idx];
      const k = key(e.ex, e.ey);
      if(!barricades.has(k)){
        barricades.set(k, { hp: 6, ttl: 360 }); // lasts for a while
      }
      placed++;
    }

    // also: small chance to relocate blue agents to threatened entrance (for visuals)
    for(const b of blues){
      // pick most pressured entrance
      const idx = order[0];
      const e = entrances[idx];
      // move a bit toward core side near entrance
      const tx = clamp(e.ex + (e.ex < core.x ? 1 : e.ex > core.x ? -1 : 0), base.x0+1, base.x1-1);
      const ty = clamp(e.ey + (e.ey < core.y ? 1 : e.ey > core.y ? -1 : 0), base.y0+1, base.y1-1);
      // simple greedy step
      const dx = Math.sign(tx - b.x);
      const dy = Math.sign(ty - b.y);
      const nx = b.x + (Math.random()<0.6 ? dx : 0);
      const ny = b.y + (Math.random()<0.6 ? dy : 0);
      if(!isBlocked(nx,ny) && !(nx===core.x && ny===core.y)){
        b.x = nx; b.y = ny;
      }
    }
  }

  // ---------- red behavior ----------
  function redStep(r){
    r.life--;
    if(r.life <= 0) return 'dead';

    // reached core => success
    if(r.x===core.x && r.y===core.y) return 'success';

    // if no path or path empty => recalc
    if(!r.path || r.path.length===0){
      const p = astar(r.x, r.y, core.x, core.y);
      r.path = p ?? [];
      if(!r.path.length){
        // wander randomly
        const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
        const d = dirs[randInt(0,3)];
        const nx=r.x+d.x, ny=r.y+d.y;
        if(!isBlocked(nx,ny)){ r.x=nx; r.y=ny; }
        r.stuck++;
        return 'ok';
      }
    }

    const next = r.path[0];
    // if next blocked by barricade => attack it a bit (simulate pushing)
    if(barricades.has(key(next.x,next.y))){
      const b = barricades.get(key(next.x,next.y));
      b.hp -= 1; // red damages barricade
      pushWindow(recentBlocks, 1); // blue successfully blocked a step
      if(b.hp <= 0){
        barricades.delete(key(next.x,next.y)); // broken
      } else {
        // remain in place
      }
      r.stuck++;
      // negative reward for this entrance
      pref[r.targetEnt] -= lrRed*0.25;
      return 'ok';
    }

    // if next is wall/border => recalc
    if(isBlocked(next.x,next.y)){
      r.path = [];
      r.stuck++;
      pref[r.targetEnt] -= lrRed*0.15;
      return 'ok';
    }

    // move
    r.x = next.x; r.y = next.y;
    r.path.shift();

    // small shaping: if makes progress toward core, reward slightly
    const dist = Math.abs(r.x-core.x)+Math.abs(r.y-core.y);
    const reward = dist < 10 ? 0.01 : 0.003;
    pref[r.targetEnt] += lrRed*reward;

    // if too stuck, maybe switch entrance preference (implicit: die soon and learn)
    if(r.stuck > 22){
      pref[r.targetEnt] -= lrRed*0.35;
      return 'dead';
    }

    return 'ok';
  }

  function resolveRedOutcome(ent, outcome){
    // update red preference by outcome
    if(outcome==='success'){
      pref[ent] += lrRed * 1.8; // big reward
    } else if(outcome==='dead'){
      pref[ent] -= lrRed * 0.9; // penalty
    }
  }

  // ---------- main sim ----------
  function simStep(){
    tick++;

    // spawn reds occasionally
    // frequency increases slightly over time (pressure)
    const spawnChance = 0.22 + 0.10*Math.min(1, tick/2000);
    if(Math.random() < spawnChance){
      spawnRed();
    }

    // blue defense update
    blueDefend();

    // red update
    const alive = [];
    for(const r of reds){
      const res = redStep(r);
      if(res==='success'){
        // record success
        pushWindow(recentSuccess, 1);
        resolveRedOutcome(r.targetEnt, 'success');
      } else if(res==='dead'){
        resolveRedOutcome(r.targetEnt, 'dead');
        // (no success)
      } else {
        alive.push(r);
      }
    }
    reds = alive;

    // small decay of prefs so it doesn't explode
    for(let i=0;i<pref.length;i++){
      pref[i] *= 0.999;
      pref[i] = clamp(pref[i], -4, 4);
    }
  }

  // ---------- metrics/progress ----------
  function updateUI(){
    elTick.textContent = String(tick);
    elRN.textContent = String(reds.length);
    elBN.textContent = String(blues.length);
    elBarrN.textContent = String(barricades.size);

    const att = sum(recentAttacks);
    const suc = sum(recentSuccess);
    const blk = sum(recentBlocks);

    elAttW.textContent = String(att);
    elSuccW.textContent = String(suc);
    elBlockW.textContent = String(blk);

    // Red "intelligence": success rate among attacks (window)
    const redRate = att > 0 ? (suc/att) : 0;
    const rP = Math.round(redRate*100);
    rPct.textContent = rP + '%';
    rBar.style.width = rP + '%';

    // Blue "intelligence": how much of attacks were blocked (proxy)
    // blocked steps is not same as blocked attacks, but gives a ‚Äúdefense pressure‚Äù feel.
    const blueRate = att > 0 ? clamp(blk / (att*6), 0, 1) : 0;
    const bP = Math.round(blueRate*100);
    bPct.textContent = bP + '%';
    bBar.style.width = bP + '%';
  }

  // ---------- draw ----------
  function draw(){
    const cw=cv.width, ch=cv.height;
    ctx.clearRect(0,0,cw,ch);

    const pad = 18;
    const size = Math.min(cw,ch) - pad*2;
    const cell = size / W;

    // bg
    ctx.fillStyle = '#0a0f1c';
    ctx.fillRect(0,0,cw,ch);

    // cells
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        const px = pad + x*cell;
        const py = pad + y*cell;

        // walls
        if(grid[y][x]===WALL){
          ctx.fillStyle = '#2b2f3f';
          ctx.fillRect(px,py,cell,cell);
        }

        // light grid
        ctx.strokeStyle = 'rgba(255,255,255,0.05)';
        ctx.strokeRect(px,py,cell,cell);
      }
    }

    // entrances
    for(const e of entrances){
      const px = pad + e.ex*cell;
      const py = pad + e.ey*cell;
      ctx.fillStyle = '#ffd60a';
      ctx.fillRect(px+cell*0.2, py+cell*0.2, cell*0.6, cell*0.6);
    }

    // barricades
    for(const [k,v] of barricades){
      const [x,y]=k.split(',').map(Number);
      const px = pad + x*cell;
      const py = pad + y*cell;
      ctx.fillStyle = '#a3a3a3';
      ctx.fillRect(px+cell*0.12, py+cell*0.12, cell*0.76, cell*0.76);

      // hp bar
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(px+cell*0.12, py+cell*0.06, cell*0.76, cell*0.08);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(px+cell*0.12, py+cell*0.06, cell*0.76*(v.hp/6), cell*0.08);
    }

    // core
    {
      const px = pad + core.x*cell;
      const py = pad + core.y*cell;
      ctx.fillStyle = '#7c3aed';
      ctx.fillRect(px+cell*0.18, py+cell*0.18, cell*0.64, cell*0.64);
    }

    // blues
    for(const b of blues){
      const px = pad + b.x*cell + cell/2;
      const py = pad + b.y*cell + cell/2;
      ctx.fillStyle = '#2a6bff';
      ctx.beginPath();
      ctx.arc(px,py,cell*0.22,0,Math.PI*2);
      ctx.fill();
    }

    // reds
    for(const r of reds){
      const px = pad + r.x*cell + cell/2;
      const py = pad + r.y*cell + cell/2;
      ctx.fillStyle = '#ff3b30';
      ctx.beginPath();
      ctx.arc(px,py,cell*0.20,0,Math.PI*2);
      ctx.fill();
    }

    // tiny overlay: entrance weights
    // show which entrance reds prefer
    const probs = softmaxProbs(pref);
    ctx.fillStyle = 'rgba(233,238,252,0.85)';
    ctx.font = '14px ui-monospace, Menlo, monospace';
    ctx.fillText(`Red pref N/E/S/W: ${probs.map(p => (p*100).toFixed(0)+'%').join(' ')}`, 18, 22);
  }

  function softmaxProbs(logits){
    const t = temperature;
    const exps = logits.map(v => Math.exp(v/t));
    const s = exps.reduce((a,b)=>a+b,0) || 1;
    return exps.map(e => e/s);
  }

  // ---------- loop ----------
  function frame(){
    if(playing){
      for(let i=0;i<stepsPerFrame;i++){
        simStep();
      }
      updateUI();
      draw();
    }
    requestAnimationFrame(frame);
  }

  // ---------- controls ----------
  btnStart.addEventListener('click', ()=>{
    playing = !playing;
    btnStart.textContent = playing ? '‚è∏ –ü–∞—É–∑–∞' : '‚ñ∂ –°—Ç–∞—Ä—Ç';
  });

  btnReset.addEventListener('click', ()=>{
    resetAll();
  });

  btnFast.addEventListener('click', ()=>{
    stepsPerFrame = Math.min(60, stepsPerFrame * 2);
  });
  btnSlow.addEventListener('click', ()=>{
    stepsPerFrame = Math.max(1, Math.floor(stepsPerFrame / 2));
  });

  // init
  resetAll();
  frame();
})();
</script>
</body>
</html>
